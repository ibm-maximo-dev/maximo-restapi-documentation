{"componentChunkName":"component---src-pages-query-savedquery-mdx","path":"/query/savedquery/","result":{"pageContext":{"frontmatter":{"title":"Saved queries"},"relativePagePath":"/query/savedquery.mdx","titleType":"append","MdxNode":{"id":"1596db60-74e5-56c0-8fa6-2dfcef4974d8","children":[],"parent":"f970b6eb-0812-5802-a8e2-eed75a203b1e","internal":{"content":"---\ntitle: Saved queries\n---\n\nMaximo Asset Management supports a feature called a Saved Query where a pre-built query for an application, such as Work Order Tracking, allows users to retrieve a common set of data (for example, a list of approved work orders). After reading this section, you can use the saved query capability to query records based on defined filter criterion with RESTful API call.\n\n## Available Queries for Object Structure\n\nFor each object structure, you can find all authorized (for the requesting user) saved queries by using the apimeta API call. See the following MXAPIASSET object structure example:\n\n|Attribute|Description|\n|--|--|\n|ispublic|If the query is public|\n|name|Query name|\n|title|Query description|\n|href|Query url|\n\n```\nGET oslc/apimeta/{osname}\n```\n\nFor example, if we would like to get the pre-defined saved query for mxapiasset, we will run\n\n```\nGET oslc/apimeta/mxapiasset\n```\n\nExpected result:\n```json\n{\n  \"queryCapability\": [\n    {\n      \"ispublic\": true,\n      \"name\": \"All\",\n      \"href\": \".../oslc/os/mxasset\"\n    },\n    {\n      \"ispublic\": true,\n      \"name\": \"publicAssets\",\n      \"javaMethod\": true,\n      \"href\": \".../oslc/os/mxasset?savedQuery=publicAssets\"\n    },\n    {\n      \"title\": \"IT Stock in Stock Locations (non-Storeroom)\",\n      \"ispublic\": true,\n      \"name\": \"ITSTOCK\",\n      \"href\": \".../oslc/os/mxasset?savedQuery=ITSTOCK\"\n    },\n    {\n      \"title\": \"X\",\n      \"ispublic\": true,\n      \"name\": \"LINKED-ASSETS\",\n      \"href\": \".../oslc/os/mxasset?savedQuery=LINKEDASSETS\"\n    },\n    {\n      title: \"Life to date cost is 80% of replacement cost\",\n      ispublic: true,\n      name: \"ASSET:Bad Actor - LTD Cost\",\n      href: \"/oslc/os/mxapiasset?savedQuery=ASSET%3ABad+Actor+-+LTD+Co st\"\n    }\n  ]\n}\n```\n\nThere are four types of saved queries for Object structures in Maximo Asset Management.\n\n### Query Method (method, java method)\n\nThis query is defined in object structureâ€™s definition class.  It is sourced from an annotated method name. This option is used if a method was implemented for query purposes. Since there are no default query methods provided, this method would be a custom code implementation by using the following code example, `@PreparedQuery(\"http://maximo.nextgen.asset#publicAssets\")`\n\n```java\n@PreparedQuery(\"http://maximo.nextgen.asset#publicAssets\") \npublic void publicAssets(MboSet assetSet) throws MXException, RemoteException\n{\n  String whereusercust=\"assetnum not in (select assetnum from assetusercust)\";\n  assetSet.setUserWhere(whereusercust);\n}\n```\n\n### Automation Script (script)\n\nThis query is run with a predefined automation script. This configuration allows for more complex queries than are normally supported by a query clause.\n\nThe creation of a script for an object structure can be defined as a query clause. When you define a script as a query clause, the script can be configured as an object structure query for use with the JSON API.\n\n![Scripting query](image/scripting.jpg)\n\n[]()\n\n### Object Structure Query Clause (osclause)\n\nThe where clause for this query is defined in this query definition. For this type, you enter a Where clause, provide a name and description for the query, and flag whether the query is public or not. The Where clause format is similar to a Where clause that is used in an application list tab. Public queries are available to everyone to use. Non-public queries are only available to the query owner.\n\n### Applications Query (appclause)\n\nThe query is sourced from a Public Saved Query of an application. Using `Asset` and `MXAPIASSET` as an example, the query can be associated with object structures in following ways:\n\n1. Open Object Structure APP. Select Query Definition from Action List, set type = appcluase, select the query from the list.\n2. Set the authorization name of MXASSET as ASSET. In apimeta, the saved query names will be listed as original name.\n3. Set the authorization name of MXASSET as MXASSET, then check load queries from all apps. If you have the access to ASSET, in apimeta, the saved query name will show as ASSET:QueryName\n\n![Application query](image/application.jpg)\n\n[]()\n\nFor the detail of OSLC Query, see Ability to set query definitions and action associations in the Object Structures application.\n\n## Execute saved query for object structures\n\nFor Maximo Asset Management RESTful APIs, the query parameter for all of the saved query is  `savedQuery`. This parameter is case-sensitive. If you apply `SAVEDQUERY` or `savedquery`, the parameter is ignored as an invalid query parameter without any errors.\n\nIn the `queryCapability` Section of APIMeta, the links for saved queries are already provided.  Take `ITSTOCK` as an example:\n\n```\nGET /oslc/os/mxapiasset?savedQuery=ITSTOCK\n```\n\n## Execute KPI clause for Object Structure\n \nBy using RESTful APIs, you can get more detail for a KPI by calling its where clause with saved query as follows:\n\n```\nGET /oslc/os/mxapiasset?savedQuery=KPI:ASSETKPI\n```\n\nThe API takes the where clause from `KPI` and apply it to the `MXASSET` object Ssructure. The KPI clause is not be available in `APIMETA` and you have to make sure the where clause in `KPI` can be applied to the main object of the object structure.  Otherwise, you will get the SQL error.\n\n## Query Template\n\nA query Template is an object structure-based template that includes the query related definition. In the collection level, you can define the page size, search attributes, and timeline attribute in the template. In the attribute level, you can add selected attributes, give the ordered information, and override the title of attribute.\n\nAfter reading this section, you will be able to create a query template for object structures, apply the template to object structure, and get selected attribute and ordered collection back.\n\nCurrently, the query template can be created by JSON API. Using MXAPIASSET as an example, you complete the following tasks where the object structure is named `MXAPIQUERYTEMPLATE` for `querytemplate:`\n\n### Create query template\n\nNormally, the query template can be created by API - MXAPIQUERYTEMPLATE. Let's start with create one for MXAPIASSET.\nAssume we have following definition for this template:\n- Page Size = 5\n- Search Attributes = assetnum, description\n- Timeline Attribute = changedate\n\n```\nPOST /oslc/os/mxapiquerytemplate?lean=1\n```\n\nBody:\n```json\n{\n  \"pagesize\": \"5\",\n  \"searchattributes\": \"assetnum,description\",\n  \"timelineattribute\": \"changedate\",\n  \"intobjectname\": \"MXAPIASSET\"\n}\n```\n\nNote this template currently doesn't have any selected attribute defined. When we apply it to MXAPIASSET, the response body of members will only contain 5 items with href. Assume the auto generated query template name is 1001, the restful call will look like\n\n``` \nGET /oslc/os/mxapiasset?querytemplate=1001&collectioncount=1&lean=1\n```\n\nExpected Response Info:\n```json\n{\n  ...\n  \"responseInfo\": {\n    \"nextPage\": {\n      \"href\": \"nextpagelink\"\n    },\n    \"totalCount\": 1152,\n    \"pagenum\": 1,\n    \"href\": \"currentpagelink\",\n    \"totalPages\": 231\n  }\n}\n```\n\nThe searchAttribute and timeline attribute are defined in query template already. We could use oslc.searchTerm and tlrange to filter the result set.\n\n```\nGET /oslc/os/mxapiasset?querytemplate=1001&oslc.searchTerm=\"PUMP\"&tlrange=-3M&collectioncount=1&lean=1\n```\n\nExpected Response Info:\n```json\n{\n  \"responseInfo\": {\n    \"nextPage\": {\n      \"href\": \"next page link\"\n    },\n    \"totalCount\": 43,\n    \"pagenum\": 1,\n    \"href\": \"current page link\",\n    \"totalPages\": 9\n  }\n}\n```\n\n#### Search strings\n\nOn Query Templates it is possible to search strings on by literal value or by words.\n\n**Tokenized** search is the default way the search is performed.\n\n```\nGET oslc/os/mxapimeter?oslc.select=metername,description&searchAttributes=metername&oslc.searchTerms=meter color\n```\n\nThe request above would produce a SQL query below:\n\n```\nSQL select [attributes] from meter  where (metername like '%METER%' or metername like '%COLOR%')\n```\n\nFor searching a string in its integrity use two pairs of double quotes\n\n```\nGET oslc/os/mxapimeter?oslc.select=metername,description&searchAttributes=metername&oslc.searchTerms=\"\"oil level\"\"\n```\n\nThe request above would produce a SQL query below:\n\n```\nSQL select [attributes] from meter  where (metername = 'OIL LEVEL')\n```\n\n\nWhile working with searchTerms remember:\n- Using 1 pair of double quotes performs a tokenized search;\n- Using 2 pairs of double quotes on search terms performs a literal search;\n- It is the same result using a pair of double quotes or no quotes;\n- Using % on search terms might mess the result;\n- Avoid using single quotes.\n \n### Set up query template with attributes\n\nIn most of the use cases we would like to have selected attribute pre-defined in query template. Here is the basic format of attribute, in general, it follows the standard oslc query attribute format and defined per attribute. Query template framework will calculate the select (oslc.select), sortby (oslc.orderBy) from definition when we apply the template to object structure.\n\n#### Basic\n\n|Format|Description|Example|\n|attribute|The attribute name from the object|assetnum|\n|relationship.attribute|The attribute name from dynamic relationship|allwo.wonum|\n\n\n```\nPOST /oslc/os/mxapiquerytemplate\n{\n  \"pagesize\": 5,\n  \"intobjectname\": \"MXASSET\",\n  \"querytemplateattr\": [\n    {\n      \"selectattrname\": \"assetnum\",\n      \"selectorder\": 1\n    },\n    {\n      \"selectattrname\": \"status\",\n      \"selectorder\": 2\n    },\n    {\n      \"selectattrname\": \"siteid\",\n      \"selectorder\": 3,\n      \"sortbyon\": true,\n      \"sortbyorder\": 0,\n      \"ascending\": true\n    }\n  ]\n}\n```\n\nAssume the templatename is 1002, the restful call will look like:\n\n```\nGET /oslc/os/mxapiasset?querytemplate=1002\n```\n\nThe result will return 5 records per page sorted by site in ascending order, each of the object will contain the assetnum, status and siteid.\n\nResponse of one record\n```json\n{\n  \"assetusercust_collectionref\": \"link to assetusercust\",\n  \"assetnum\": \"1001\",\n  \"_rowstamp\": \"1195406\",\n  \"status_description\": \"Not Ready\",\n  \"assetopskd_collectionref\": \"link to assetopskd\",\n  \"assetmeter_collectionref\": \"link to assetmeter\",\n  \"status\": \"NOT READY\",\n  \"assetmntskd_collectionref\": \"link to assetmntskd\",\n  \"siteid\": \"BEDFORD\",\n  \"assetspec_collectionref\": \"link to assetspec\",\n  \"href\": \"link to current record\"\n}\n```\n\n\n\n#### Advanced Fromat (*)\n\nWe also provide the capability to use the complex syntax with * notation for more advanced requirement.\n\n|Format|Description|Example|\n|rel$relationship.attribute*|The attribute name from dynamic relationship (1:n)|rel$allwo.wonum*|\n|rel$relationship.exp$formula*|The formula for dynamic relationship (1:n)|rel$allwo.exp$formula*|\n|rel$relationship.relationship.attribute*|The attribute name from multiple level relationship (1:n)|rel$allwo.pm.pmnum*|\n|childobjectname.attribute*|The attribute name from child object (1:n)|location.location*|\n|exp$formula*|The formula for the object|exp$formula*|\n\nAssume we want to build the following clause\n\n```\noslc.select=rel.allwo{wonum,siteid,exp.formula,pm{pmnum,description}},location{location,description,allwo.wonum},assetnum,allwo.wonum\n```\n\nIt can be translated to x.y.z* syntax as following:\n\n```\nrel$allwo.wonum*\nrel$allwo.pm.description*\t\nassetnum\nrel$allwo.siteid*\t\nlocation.location*\nallwo.wonum\nrel$allwo.exp$formula*\nlocation.descrption*\nrel$allwo.pm.pmnum*\nlocation.allwo$wonum*\t\n```\n\n#### Differences between basic and advanced format\n\nIt is easy to get confused about syntax, let's take a deeper look at what's the differences among relName.AttrName, objName.attrName* and rel$relName.attrName*, taking MXAPIPO as an example and assume we need to deal with this relationship: Name = VENDOR, Parent = PO, Child = COMPANIES and we want to get the name of company.\n\nvendor.name: It's used to get the name of first company while we don't have companies defined as child object in MXAPIPO, it will only take the first record back even it could be one to many.\ncompanies.name*: It will convert to companies{name} by Query Template and used when we have COMPANIES as our child object in MXAPIPO (and relationship could be VENDOR), then we have to use objectname instead of relationship name to get the record back, and it will return multiple records if the result is one to many.\nrel$vendor.name*: It will convert to rel.vendor{name} by Query Template and used when we don't have COMPANIES as our child object in MXPO but we ant to get all records back if the result is one to many","type":"Mdx","contentDigest":"e41e96981acf4aea2769258e92d2adee","owner":"gatsby-plugin-mdx","counter":174},"frontmatter":{"title":"Saved queries"},"exports":{},"rawBody":"---\ntitle: Saved queries\n---\n\nMaximo Asset Management supports a feature called a Saved Query where a pre-built query for an application, such as Work Order Tracking, allows users to retrieve a common set of data (for example, a list of approved work orders). After reading this section, you can use the saved query capability to query records based on defined filter criterion with RESTful API call.\n\n## Available Queries for Object Structure\n\nFor each object structure, you can find all authorized (for the requesting user) saved queries by using the apimeta API call. See the following MXAPIASSET object structure example:\n\n|Attribute|Description|\n|--|--|\n|ispublic|If the query is public|\n|name|Query name|\n|title|Query description|\n|href|Query url|\n\n```\nGET oslc/apimeta/{osname}\n```\n\nFor example, if we would like to get the pre-defined saved query for mxapiasset, we will run\n\n```\nGET oslc/apimeta/mxapiasset\n```\n\nExpected result:\n```json\n{\n  \"queryCapability\": [\n    {\n      \"ispublic\": true,\n      \"name\": \"All\",\n      \"href\": \".../oslc/os/mxasset\"\n    },\n    {\n      \"ispublic\": true,\n      \"name\": \"publicAssets\",\n      \"javaMethod\": true,\n      \"href\": \".../oslc/os/mxasset?savedQuery=publicAssets\"\n    },\n    {\n      \"title\": \"IT Stock in Stock Locations (non-Storeroom)\",\n      \"ispublic\": true,\n      \"name\": \"ITSTOCK\",\n      \"href\": \".../oslc/os/mxasset?savedQuery=ITSTOCK\"\n    },\n    {\n      \"title\": \"X\",\n      \"ispublic\": true,\n      \"name\": \"LINKED-ASSETS\",\n      \"href\": \".../oslc/os/mxasset?savedQuery=LINKEDASSETS\"\n    },\n    {\n      title: \"Life to date cost is 80% of replacement cost\",\n      ispublic: true,\n      name: \"ASSET:Bad Actor - LTD Cost\",\n      href: \"/oslc/os/mxapiasset?savedQuery=ASSET%3ABad+Actor+-+LTD+Co st\"\n    }\n  ]\n}\n```\n\nThere are four types of saved queries for Object structures in Maximo Asset Management.\n\n### Query Method (method, java method)\n\nThis query is defined in object structureâ€™s definition class.  It is sourced from an annotated method name. This option is used if a method was implemented for query purposes. Since there are no default query methods provided, this method would be a custom code implementation by using the following code example, `@PreparedQuery(\"http://maximo.nextgen.asset#publicAssets\")`\n\n```java\n@PreparedQuery(\"http://maximo.nextgen.asset#publicAssets\") \npublic void publicAssets(MboSet assetSet) throws MXException, RemoteException\n{\n  String whereusercust=\"assetnum not in (select assetnum from assetusercust)\";\n  assetSet.setUserWhere(whereusercust);\n}\n```\n\n### Automation Script (script)\n\nThis query is run with a predefined automation script. This configuration allows for more complex queries than are normally supported by a query clause.\n\nThe creation of a script for an object structure can be defined as a query clause. When you define a script as a query clause, the script can be configured as an object structure query for use with the JSON API.\n\n![Scripting query](image/scripting.jpg)\n\n[]()\n\n### Object Structure Query Clause (osclause)\n\nThe where clause for this query is defined in this query definition. For this type, you enter a Where clause, provide a name and description for the query, and flag whether the query is public or not. The Where clause format is similar to a Where clause that is used in an application list tab. Public queries are available to everyone to use. Non-public queries are only available to the query owner.\n\n### Applications Query (appclause)\n\nThe query is sourced from a Public Saved Query of an application. Using `Asset` and `MXAPIASSET` as an example, the query can be associated with object structures in following ways:\n\n1. Open Object Structure APP. Select Query Definition from Action List, set type = appcluase, select the query from the list.\n2. Set the authorization name of MXASSET as ASSET. In apimeta, the saved query names will be listed as original name.\n3. Set the authorization name of MXASSET as MXASSET, then check load queries from all apps. If you have the access to ASSET, in apimeta, the saved query name will show as ASSET:QueryName\n\n![Application query](image/application.jpg)\n\n[]()\n\nFor the detail of OSLC Query, see Ability to set query definitions and action associations in the Object Structures application.\n\n## Execute saved query for object structures\n\nFor Maximo Asset Management RESTful APIs, the query parameter for all of the saved query is  `savedQuery`. This parameter is case-sensitive. If you apply `SAVEDQUERY` or `savedquery`, the parameter is ignored as an invalid query parameter without any errors.\n\nIn the `queryCapability` Section of APIMeta, the links for saved queries are already provided.  Take `ITSTOCK` as an example:\n\n```\nGET /oslc/os/mxapiasset?savedQuery=ITSTOCK\n```\n\n## Execute KPI clause for Object Structure\n \nBy using RESTful APIs, you can get more detail for a KPI by calling its where clause with saved query as follows:\n\n```\nGET /oslc/os/mxapiasset?savedQuery=KPI:ASSETKPI\n```\n\nThe API takes the where clause from `KPI` and apply it to the `MXASSET` object Ssructure. The KPI clause is not be available in `APIMETA` and you have to make sure the where clause in `KPI` can be applied to the main object of the object structure.  Otherwise, you will get the SQL error.\n\n## Query Template\n\nA query Template is an object structure-based template that includes the query related definition. In the collection level, you can define the page size, search attributes, and timeline attribute in the template. In the attribute level, you can add selected attributes, give the ordered information, and override the title of attribute.\n\nAfter reading this section, you will be able to create a query template for object structures, apply the template to object structure, and get selected attribute and ordered collection back.\n\nCurrently, the query template can be created by JSON API. Using MXAPIASSET as an example, you complete the following tasks where the object structure is named `MXAPIQUERYTEMPLATE` for `querytemplate:`\n\n### Create query template\n\nNormally, the query template can be created by API - MXAPIQUERYTEMPLATE. Let's start with create one for MXAPIASSET.\nAssume we have following definition for this template:\n- Page Size = 5\n- Search Attributes = assetnum, description\n- Timeline Attribute = changedate\n\n```\nPOST /oslc/os/mxapiquerytemplate?lean=1\n```\n\nBody:\n```json\n{\n  \"pagesize\": \"5\",\n  \"searchattributes\": \"assetnum,description\",\n  \"timelineattribute\": \"changedate\",\n  \"intobjectname\": \"MXAPIASSET\"\n}\n```\n\nNote this template currently doesn't have any selected attribute defined. When we apply it to MXAPIASSET, the response body of members will only contain 5 items with href. Assume the auto generated query template name is 1001, the restful call will look like\n\n``` \nGET /oslc/os/mxapiasset?querytemplate=1001&collectioncount=1&lean=1\n```\n\nExpected Response Info:\n```json\n{\n  ...\n  \"responseInfo\": {\n    \"nextPage\": {\n      \"href\": \"nextpagelink\"\n    },\n    \"totalCount\": 1152,\n    \"pagenum\": 1,\n    \"href\": \"currentpagelink\",\n    \"totalPages\": 231\n  }\n}\n```\n\nThe searchAttribute and timeline attribute are defined in query template already. We could use oslc.searchTerm and tlrange to filter the result set.\n\n```\nGET /oslc/os/mxapiasset?querytemplate=1001&oslc.searchTerm=\"PUMP\"&tlrange=-3M&collectioncount=1&lean=1\n```\n\nExpected Response Info:\n```json\n{\n  \"responseInfo\": {\n    \"nextPage\": {\n      \"href\": \"next page link\"\n    },\n    \"totalCount\": 43,\n    \"pagenum\": 1,\n    \"href\": \"current page link\",\n    \"totalPages\": 9\n  }\n}\n```\n\n#### Search strings\n\nOn Query Templates it is possible to search strings on by literal value or by words.\n\n**Tokenized** search is the default way the search is performed.\n\n```\nGET oslc/os/mxapimeter?oslc.select=metername,description&searchAttributes=metername&oslc.searchTerms=meter color\n```\n\nThe request above would produce a SQL query below:\n\n```\nSQL select [attributes] from meter  where (metername like '%METER%' or metername like '%COLOR%')\n```\n\nFor searching a string in its integrity use two pairs of double quotes\n\n```\nGET oslc/os/mxapimeter?oslc.select=metername,description&searchAttributes=metername&oslc.searchTerms=\"\"oil level\"\"\n```\n\nThe request above would produce a SQL query below:\n\n```\nSQL select [attributes] from meter  where (metername = 'OIL LEVEL')\n```\n\n\nWhile working with searchTerms remember:\n- Using 1 pair of double quotes performs a tokenized search;\n- Using 2 pairs of double quotes on search terms performs a literal search;\n- It is the same result using a pair of double quotes or no quotes;\n- Using % on search terms might mess the result;\n- Avoid using single quotes.\n \n### Set up query template with attributes\n\nIn most of the use cases we would like to have selected attribute pre-defined in query template. Here is the basic format of attribute, in general, it follows the standard oslc query attribute format and defined per attribute. Query template framework will calculate the select (oslc.select), sortby (oslc.orderBy) from definition when we apply the template to object structure.\n\n#### Basic\n\n|Format|Description|Example|\n|attribute|The attribute name from the object|assetnum|\n|relationship.attribute|The attribute name from dynamic relationship|allwo.wonum|\n\n\n```\nPOST /oslc/os/mxapiquerytemplate\n{\n  \"pagesize\": 5,\n  \"intobjectname\": \"MXASSET\",\n  \"querytemplateattr\": [\n    {\n      \"selectattrname\": \"assetnum\",\n      \"selectorder\": 1\n    },\n    {\n      \"selectattrname\": \"status\",\n      \"selectorder\": 2\n    },\n    {\n      \"selectattrname\": \"siteid\",\n      \"selectorder\": 3,\n      \"sortbyon\": true,\n      \"sortbyorder\": 0,\n      \"ascending\": true\n    }\n  ]\n}\n```\n\nAssume the templatename is 1002, the restful call will look like:\n\n```\nGET /oslc/os/mxapiasset?querytemplate=1002\n```\n\nThe result will return 5 records per page sorted by site in ascending order, each of the object will contain the assetnum, status and siteid.\n\nResponse of one record\n```json\n{\n  \"assetusercust_collectionref\": \"link to assetusercust\",\n  \"assetnum\": \"1001\",\n  \"_rowstamp\": \"1195406\",\n  \"status_description\": \"Not Ready\",\n  \"assetopskd_collectionref\": \"link to assetopskd\",\n  \"assetmeter_collectionref\": \"link to assetmeter\",\n  \"status\": \"NOT READY\",\n  \"assetmntskd_collectionref\": \"link to assetmntskd\",\n  \"siteid\": \"BEDFORD\",\n  \"assetspec_collectionref\": \"link to assetspec\",\n  \"href\": \"link to current record\"\n}\n```\n\n\n\n#### Advanced Fromat (*)\n\nWe also provide the capability to use the complex syntax with * notation for more advanced requirement.\n\n|Format|Description|Example|\n|rel$relationship.attribute*|The attribute name from dynamic relationship (1:n)|rel$allwo.wonum*|\n|rel$relationship.exp$formula*|The formula for dynamic relationship (1:n)|rel$allwo.exp$formula*|\n|rel$relationship.relationship.attribute*|The attribute name from multiple level relationship (1:n)|rel$allwo.pm.pmnum*|\n|childobjectname.attribute*|The attribute name from child object (1:n)|location.location*|\n|exp$formula*|The formula for the object|exp$formula*|\n\nAssume we want to build the following clause\n\n```\noslc.select=rel.allwo{wonum,siteid,exp.formula,pm{pmnum,description}},location{location,description,allwo.wonum},assetnum,allwo.wonum\n```\n\nIt can be translated to x.y.z* syntax as following:\n\n```\nrel$allwo.wonum*\nrel$allwo.pm.description*\t\nassetnum\nrel$allwo.siteid*\t\nlocation.location*\nallwo.wonum\nrel$allwo.exp$formula*\nlocation.descrption*\nrel$allwo.pm.pmnum*\nlocation.allwo$wonum*\t\n```\n\n#### Differences between basic and advanced format\n\nIt is easy to get confused about syntax, let's take a deeper look at what's the differences among relName.AttrName, objName.attrName* and rel$relName.attrName*, taking MXAPIPO as an example and assume we need to deal with this relationship: Name = VENDOR, Parent = PO, Child = COMPANIES and we want to get the name of company.\n\nvendor.name: It's used to get the name of first company while we don't have companies defined as child object in MXAPIPO, it will only take the first record back even it could be one to many.\ncompanies.name*: It will convert to companies{name} by Query Template and used when we have COMPANIES as our child object in MXAPIPO (and relationship could be VENDOR), then we have to use objectname instead of relationship name to get the record back, and it will return multiple records if the result is one to many.\nrel$vendor.name*: It will convert to rel.vendor{name} by Query Template and used when we don't have COMPANIES as our child object in MXPO but we ant to get all records back if the result is one to many","fileAbsolutePath":"/home/travis/build/maximo-app-framework/maximo-restapi-documentation/src/pages/query/savedquery.mdx"}}},"staticQueryHashes":["1364590287","137577622","2102389209","2456312558","2746626797","3018647132","3037994772","768070550"]}