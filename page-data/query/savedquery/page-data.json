{"componentChunkName":"component---src-pages-query-savedquery-mdx","path":"/query/savedquery/","result":{"pageContext":{"frontmatter":{"title":"Saved Query"},"relativePagePath":"/query/savedquery.mdx","titleType":"append","MdxNode":{"id":"1596db60-74e5-56c0-8fa6-2dfcef4974d8","children":[],"parent":"f970b6eb-0812-5802-a8e2-eed75a203b1e","internal":{"content":"---\ntitle: Saved Query\n----\n\nMaximo supports a feature called a Saved Query where a pre-built query for an application, such as Work Order Tracking, which allows a user to easily retrieve a common set of data (example: a list of Approved Work Order). After reading this section, you can use the saved query capability to query records based on defined filter criterion with RESTful API call.\n\n## Available Queries for Object Structure\n\nFor each Object Structure, you can find all authorized (for the requesting user) saved queries using the apimeta api call listed below (with MXASSET Object Structure as an example)\n\n|Attribute|Description|\n|--|--|\n|ispublic|If the query is public|\n|name|Query name|\n|title|Query description|\n|href|Query url|\n\n```\nGET oslc/apimeta/{osname}\n```\n\nFor example, if we would like to get the pre-defined saved query for mxapiasset, we will run \n```\nGET oslc/apimeta/mxapiasset\n```\n\nExpected result:\n```json\n{\n  \"queryCapability\": [\n    {\n      \"ispublic\": true,\n      \"name\": \"All\",\n      \"href\": \".../oslc/os/mxasset\"\n    },\n    {\n      \"ispublic\": true,\n      \"name\": \"publicAssets\",\n      \"javaMethod\": true,\n      \"href\": \".../oslc/os/mxasset?savedQuery=publicAssets\"\n    },\n    {\n      \"title\": \"IT Stock in Stock Locations (non-Storeroom)\",\n      \"ispublic\": true,\n      \"name\": \"ITSTOCK\",\n      \"href\": \".../oslc/os/mxasset?savedQuery=ITSTOCK\"\n    },\n    {\n      \"title\": \"X\",\n      \"ispublic\": true,\n      \"name\": \"LINKED-ASSETS\",\n      \"href\": \".../oslc/os/mxasset?savedQuery=LINKEDASSETS\"\n    },\n    {\n      title: \"Life to date cost is 80% of replacement cost\",\n      ispublic: true,\n      name: \"ASSET:Bad Actor - LTD Cost\",\n      href: \"/oslc/os/mxapiasset?savedQuery=ASSET%3ABad+Actor+-+LTD+Co st\"\n    }\n  ]\n}\n```\n\nIn Maximo, we have 4 types of saved queries for Object Structure\n\n### Query Method (method, java method)\n\nThis query is defined in Object Structure's definition class. It is sourced from an annotated method name.\nThis option would be used if a method was implemented for query purposes. There are no default query methods provided, this would be a custom code implementation.\n\nThe code example is as following,\n\n```java\n@PreparedQuery(\"http://maximo.nextgen.asset#publicAssets\") \npublic void publicAssets(MboSet assetSet) throws MXException, RemoteException\n{\n  String whereusercust=\"assetnum not in (select assetnum from assetusercust)\";\n  assetSet.setUserWhere(whereusercust);\n}\n```\n\n### Automation Script (script)\n\nThis query is run with a predefined automation script. This configuration allows for more complex queries than are normally supported by a query clause.\n\nThe creation of a script for an object structure can be defined as a query clause. When you define a script as a query clause, the script can be configured as an object structure query for use with the JSON API.\n\n![Scripting query](image/scripting.jpg)\n\n[]()\n\n### Object Structure Query Clause (osclause)\n\nThe where clause for this query is defined in this query definition. For this type, you enter a Where clause, provide a name and description for the query, and flag whether the query is public or not. The Where clause format is similar to a Where clause that is used in an application List tab. Public queries are available to everyone to use.\nNon-public queries are only available to the query owner.\n\n### Applications Query (appclause)\nThe query is sourced from a Public Saved Query of an application. It could be associated with Object Structure in following ways,\n\nUsing Asset and MXASSET as an example,\n\n1. Open Object Structure APP. Select Query Definition from Action List, set type = appcluase, select the query from the list.\n2. Set the authorization name of MXASSET as ASSET. In apimeta, the saved query names will be listed as original name.\n3. Set the authorization name of MXASSET as MXASSET, then check load queries from all apps. If you have the access to ASSET, in apimeta, the saved query name will show as ASSET:QueryName\n\n![Application query](image/application.jpg)\n\n[]()\n\nFor the detail of OSLC Query, see Ability to set query definitions and action associations in the Object Structures application.\n\n## Execute Saved Query for Object Structure\n\nIn Maximo RESTful API, the query parameter for all of the saved query is savedQuery. Note, this parameter is case-sensitive. If you apply SAVEDQUERY or savedquery, it will be ignored as invalid query parameter without any error.\n\nIn the queryCapability Section of APIMeta, the links for saved queries are already provided. Take ITSTOCK as an example:\n\n```\nGET /oslc/os/mxapiasset?savedQuery=ITSTOCK\n```\n\n## Execute KPI clause for Object Structure\n \nIn Maximo RESTful API, we could get more detail for KPI by calling its where clause with saved query as following,\n\n```\nGET /oslc/os/mxapiasset?savedQuery=KPI:ASSETKPI\n```\n\nAPI will take the where clause from KPI and apply it to MXAPIASSET Object Structure.\nNote, KPI clause will not be available in APIMETA. And, you have to make sure the where clause in KPI could be applied to the main object of the Object Structure. Otherwise you will get the SQL error.\n\n## Query Template\n\nQuery Template is an object structure based template with the query related definition, for example, page size, search attributes and timeline attribute. We can also specify the attribute parameters, for example, selected attribute, sortby, and alias.\n\nAfter reading this section, you will be able to create a Query Template for Object Structure and understand how to apply it to Object Structure.\n\n### Create query template\n\nNormally, the query template can be created by API - MXAPIQUERYTEMPLATE. Let's start with create one for MXAPIASSET.\nAssume we have following definition for this template:\n- Page Size = 5\n- Search Attributes = assetnum, description\n- Timeline Attribute = changedate\n\n```\nPOST /oslc/os/mxapiquerytemplate?lean=1\n```\n\nBody:\n```json\n{\n  \"pagesize\": \"5\",\n  \"searchattributes\": \"assetnum,description\",\n  \"timelineattribute\": \"changedate\",\n  \"intobjectname\": \"MXAPIASSET\"\n}\n```\n\nNote this template currently doesn't have any selected attribute defined. When we apply it to MXAPIASSET, the response body of members will only contain 5 items with href. Assume the auto generated query template name is 1001, the restful call will look like\n\n``` \nGET /oslc/os/mxapiasset?querytemplate=1001&collectioncount=1&lean=1\n```\n\nExpected Response Info:\n```json\n{\n  ...\n  \"responseInfo\": {\n    \"nextPage\": {\n      \"href\": \"nextpagelink\"\n    },\n    \"totalCount\": 1152,\n    \"pagenum\": 1,\n    \"href\": \"currentpagelink\",\n    \"totalPages\": 231\n  }\n}\n```\n\nThe searchAttribute and timeline attribute are defined in query template already. We could use oslc.searchTerm and tlrange to filter the result set.\n\n```\nGET /oslc/os/mxapiasset?querytemplate=1001&oslc.searchTerm=\"PUMP\"&tlrange=-3M&collectioncount=1&lean=1\n```\n\nExpected Response Info:\n```json\n{\n  \"responseInfo\": {\n    \"nextPage\": {\n      \"href\": \"next page link\"\n    },\n    \"totalCount\": 43,\n    \"pagenum\": 1,\n    \"href\": \"current page link\",\n    \"totalPages\": 9\n  }\n}\n```\n \n### Set up query template with attributes\n\nIn most of the use cases we would like to have selected attribute pre-defined in query template. Here is the basic format of attribute, in general, it follows the standard oslc query attribute format and defined per attribute. Query template framework will calculate the select (oslc.select), sortby (oslc.orderBy) from definition when we apply the template to object structure.\n\n#### Basic\n\n|Format|Description|Example|\n|attribute|The attribute name from the object|assetnum|\n|relationship.attribute|The attribute name from dynamic relationship|allwo.wonum|\n\n\n```\nPOST /oslc/os/mxapiquerytemplate\n{\n  \"pagesize\": 5,\n  \"intobjectname\": \"MXASSET\",\n  \"querytemplateattr\": [\n    {\n      \"selectattrname\": \"assetnum\",\n      \"selectorder\": 1\n    },\n    {\n      \"selectattrname\": \"status\",\n      \"selectorder\": 2\n    },\n    {\n      \"selectattrname\": \"siteid\",\n      \"selectorder\": 3,\n      \"sortbyon\": true,\n      \"sortbyorder\": 0,\n      \"ascending\": true\n    }\n  ]\n}\n```\n\nAssume the templatename is 1002, the restful call will look like:\n\n```\nGET /oslc/os/mxapiasset?querytemplate=1002\n```\n\nThe result will return 5 records per page sorted by site in ascending order, each of the object will contain the assetnum, status and siteid.\n\nResponse of one record\n```json\n{\n  \"assetusercust_collectionref\": \"link to assetusercust\",\n  \"assetnum\": \"1001\",\n  \"_rowstamp\": \"1195406\",\n  \"status_description\": \"Not Ready\",\n  \"assetopskd_collectionref\": \"link to assetopskd\",\n  \"assetmeter_collectionref\": \"link to assetmeter\",\n  \"status\": \"NOT READY\",\n  \"assetmntskd_collectionref\": \"link to assetmntskd\",\n  \"siteid\": \"BEDFORD\",\n  \"assetspec_collectionref\": \"link to assetspec\",\n  \"href\": \"link to current record\"\n}\n```\n\n\n\n#### Advanced Fromat (*)\n\nWe also provide the capability to use the complex syntax with * notation for more advanced requirement.\n\n|Format|Description|Example|\n|rel$relationship.attribute*|The attribute name from dynamic relationship (1:n)|rel$allwo.wonum*|\n|rel$relationship.exp$formula*|The formula for dynamic relationship (1:n)|rel$allwo.exp$formula*|\n|rel$relationship.relationship.attribute*|The attribute name from multiple level relationship (1:n)|rel$allwo.pm.pmnum*|\n|childobjectname.attribute*|The attribute name from child object (1:n)|location.location*|\n|exp$formula*|The formula for the object|exp$formula*|\n\nAssume we want to build the following clause\n\n```\noslc.select=rel.allwo{wonum,siteid,exp.formula,pm{pmnum,description}},location{location,description,allwo.wonum},assetnum,allwo.wonum\n```\n\nIt can be translated to x.y.z* syntax as following:\n\n```\nrel$allwo.wonum*\nrel$allwo.pm.description*\t\nassetnum\nrel$allwo.siteid*\t\nlocation.location*\nallwo.wonum\nrel$allwo.exp$formula*\nlocation.descrption*\nrel$allwo.pm.pmnum*\nlocation.allwo$wonum*\t\n```\n\n#### Differences between basic and advanced format\n\nIt is easy to get confused about syntax, let's take a deeper look at what's the differences among relName.AttrName, objName.attrName* and rel$relName.attrName*, taking MXAPIPO as an example and assume we need to deal with this relationship: Name = VENDOR, Parent = PO, Child = COMPANIES and we want to get the name of company.\n\nvendor.name: It's used to get the name of first company while we don't have companies defined as child object in MXAPIPO, it will only take the first record back even it could be one to many.\ncompanies.name*: It will convert to companies{name} by Query Template and used when we have COMPANIES as our child object in MXAPIPO (and relationship could be VENDOR), then we have to use objectname instead of relationship name to get the record back, and it will return multiple records if the result is one to many.\nrel$vendor.name*: It will convert to rel.vendor{name} by Query Template and used when we don't have COMPANIES as our child object in MXPO but we ant to get all records back if the result is one to many","type":"Mdx","contentDigest":"ec5976d776251b43d5a2fd0ae7f4a486","owner":"gatsby-plugin-mdx","counter":145},"frontmatter":{"title":"Saved Query"},"exports":{},"rawBody":"---\ntitle: Saved Query\n----\n\nMaximo supports a feature called a Saved Query where a pre-built query for an application, such as Work Order Tracking, which allows a user to easily retrieve a common set of data (example: a list of Approved Work Order). After reading this section, you can use the saved query capability to query records based on defined filter criterion with RESTful API call.\n\n## Available Queries for Object Structure\n\nFor each Object Structure, you can find all authorized (for the requesting user) saved queries using the apimeta api call listed below (with MXASSET Object Structure as an example)\n\n|Attribute|Description|\n|--|--|\n|ispublic|If the query is public|\n|name|Query name|\n|title|Query description|\n|href|Query url|\n\n```\nGET oslc/apimeta/{osname}\n```\n\nFor example, if we would like to get the pre-defined saved query for mxapiasset, we will run \n```\nGET oslc/apimeta/mxapiasset\n```\n\nExpected result:\n```json\n{\n  \"queryCapability\": [\n    {\n      \"ispublic\": true,\n      \"name\": \"All\",\n      \"href\": \".../oslc/os/mxasset\"\n    },\n    {\n      \"ispublic\": true,\n      \"name\": \"publicAssets\",\n      \"javaMethod\": true,\n      \"href\": \".../oslc/os/mxasset?savedQuery=publicAssets\"\n    },\n    {\n      \"title\": \"IT Stock in Stock Locations (non-Storeroom)\",\n      \"ispublic\": true,\n      \"name\": \"ITSTOCK\",\n      \"href\": \".../oslc/os/mxasset?savedQuery=ITSTOCK\"\n    },\n    {\n      \"title\": \"X\",\n      \"ispublic\": true,\n      \"name\": \"LINKED-ASSETS\",\n      \"href\": \".../oslc/os/mxasset?savedQuery=LINKEDASSETS\"\n    },\n    {\n      title: \"Life to date cost is 80% of replacement cost\",\n      ispublic: true,\n      name: \"ASSET:Bad Actor - LTD Cost\",\n      href: \"/oslc/os/mxapiasset?savedQuery=ASSET%3ABad+Actor+-+LTD+Co st\"\n    }\n  ]\n}\n```\n\nIn Maximo, we have 4 types of saved queries for Object Structure\n\n### Query Method (method, java method)\n\nThis query is defined in Object Structure's definition class. It is sourced from an annotated method name.\nThis option would be used if a method was implemented for query purposes. There are no default query methods provided, this would be a custom code implementation.\n\nThe code example is as following,\n\n```java\n@PreparedQuery(\"http://maximo.nextgen.asset#publicAssets\") \npublic void publicAssets(MboSet assetSet) throws MXException, RemoteException\n{\n  String whereusercust=\"assetnum not in (select assetnum from assetusercust)\";\n  assetSet.setUserWhere(whereusercust);\n}\n```\n\n### Automation Script (script)\n\nThis query is run with a predefined automation script. This configuration allows for more complex queries than are normally supported by a query clause.\n\nThe creation of a script for an object structure can be defined as a query clause. When you define a script as a query clause, the script can be configured as an object structure query for use with the JSON API.\n\n![Scripting query](image/scripting.jpg)\n\n[]()\n\n### Object Structure Query Clause (osclause)\n\nThe where clause for this query is defined in this query definition. For this type, you enter a Where clause, provide a name and description for the query, and flag whether the query is public or not. The Where clause format is similar to a Where clause that is used in an application List tab. Public queries are available to everyone to use.\nNon-public queries are only available to the query owner.\n\n### Applications Query (appclause)\nThe query is sourced from a Public Saved Query of an application. It could be associated with Object Structure in following ways,\n\nUsing Asset and MXASSET as an example,\n\n1. Open Object Structure APP. Select Query Definition from Action List, set type = appcluase, select the query from the list.\n2. Set the authorization name of MXASSET as ASSET. In apimeta, the saved query names will be listed as original name.\n3. Set the authorization name of MXASSET as MXASSET, then check load queries from all apps. If you have the access to ASSET, in apimeta, the saved query name will show as ASSET:QueryName\n\n![Application query](image/application.jpg)\n\n[]()\n\nFor the detail of OSLC Query, see Ability to set query definitions and action associations in the Object Structures application.\n\n## Execute Saved Query for Object Structure\n\nIn Maximo RESTful API, the query parameter for all of the saved query is savedQuery. Note, this parameter is case-sensitive. If you apply SAVEDQUERY or savedquery, it will be ignored as invalid query parameter without any error.\n\nIn the queryCapability Section of APIMeta, the links for saved queries are already provided. Take ITSTOCK as an example:\n\n```\nGET /oslc/os/mxapiasset?savedQuery=ITSTOCK\n```\n\n## Execute KPI clause for Object Structure\n \nIn Maximo RESTful API, we could get more detail for KPI by calling its where clause with saved query as following,\n\n```\nGET /oslc/os/mxapiasset?savedQuery=KPI:ASSETKPI\n```\n\nAPI will take the where clause from KPI and apply it to MXAPIASSET Object Structure.\nNote, KPI clause will not be available in APIMETA. And, you have to make sure the where clause in KPI could be applied to the main object of the Object Structure. Otherwise you will get the SQL error.\n\n## Query Template\n\nQuery Template is an object structure based template with the query related definition, for example, page size, search attributes and timeline attribute. We can also specify the attribute parameters, for example, selected attribute, sortby, and alias.\n\nAfter reading this section, you will be able to create a Query Template for Object Structure and understand how to apply it to Object Structure.\n\n### Create query template\n\nNormally, the query template can be created by API - MXAPIQUERYTEMPLATE. Let's start with create one for MXAPIASSET.\nAssume we have following definition for this template:\n- Page Size = 5\n- Search Attributes = assetnum, description\n- Timeline Attribute = changedate\n\n```\nPOST /oslc/os/mxapiquerytemplate?lean=1\n```\n\nBody:\n```json\n{\n  \"pagesize\": \"5\",\n  \"searchattributes\": \"assetnum,description\",\n  \"timelineattribute\": \"changedate\",\n  \"intobjectname\": \"MXAPIASSET\"\n}\n```\n\nNote this template currently doesn't have any selected attribute defined. When we apply it to MXAPIASSET, the response body of members will only contain 5 items with href. Assume the auto generated query template name is 1001, the restful call will look like\n\n``` \nGET /oslc/os/mxapiasset?querytemplate=1001&collectioncount=1&lean=1\n```\n\nExpected Response Info:\n```json\n{\n  ...\n  \"responseInfo\": {\n    \"nextPage\": {\n      \"href\": \"nextpagelink\"\n    },\n    \"totalCount\": 1152,\n    \"pagenum\": 1,\n    \"href\": \"currentpagelink\",\n    \"totalPages\": 231\n  }\n}\n```\n\nThe searchAttribute and timeline attribute are defined in query template already. We could use oslc.searchTerm and tlrange to filter the result set.\n\n```\nGET /oslc/os/mxapiasset?querytemplate=1001&oslc.searchTerm=\"PUMP\"&tlrange=-3M&collectioncount=1&lean=1\n```\n\nExpected Response Info:\n```json\n{\n  \"responseInfo\": {\n    \"nextPage\": {\n      \"href\": \"next page link\"\n    },\n    \"totalCount\": 43,\n    \"pagenum\": 1,\n    \"href\": \"current page link\",\n    \"totalPages\": 9\n  }\n}\n```\n \n### Set up query template with attributes\n\nIn most of the use cases we would like to have selected attribute pre-defined in query template. Here is the basic format of attribute, in general, it follows the standard oslc query attribute format and defined per attribute. Query template framework will calculate the select (oslc.select), sortby (oslc.orderBy) from definition when we apply the template to object structure.\n\n#### Basic\n\n|Format|Description|Example|\n|attribute|The attribute name from the object|assetnum|\n|relationship.attribute|The attribute name from dynamic relationship|allwo.wonum|\n\n\n```\nPOST /oslc/os/mxapiquerytemplate\n{\n  \"pagesize\": 5,\n  \"intobjectname\": \"MXASSET\",\n  \"querytemplateattr\": [\n    {\n      \"selectattrname\": \"assetnum\",\n      \"selectorder\": 1\n    },\n    {\n      \"selectattrname\": \"status\",\n      \"selectorder\": 2\n    },\n    {\n      \"selectattrname\": \"siteid\",\n      \"selectorder\": 3,\n      \"sortbyon\": true,\n      \"sortbyorder\": 0,\n      \"ascending\": true\n    }\n  ]\n}\n```\n\nAssume the templatename is 1002, the restful call will look like:\n\n```\nGET /oslc/os/mxapiasset?querytemplate=1002\n```\n\nThe result will return 5 records per page sorted by site in ascending order, each of the object will contain the assetnum, status and siteid.\n\nResponse of one record\n```json\n{\n  \"assetusercust_collectionref\": \"link to assetusercust\",\n  \"assetnum\": \"1001\",\n  \"_rowstamp\": \"1195406\",\n  \"status_description\": \"Not Ready\",\n  \"assetopskd_collectionref\": \"link to assetopskd\",\n  \"assetmeter_collectionref\": \"link to assetmeter\",\n  \"status\": \"NOT READY\",\n  \"assetmntskd_collectionref\": \"link to assetmntskd\",\n  \"siteid\": \"BEDFORD\",\n  \"assetspec_collectionref\": \"link to assetspec\",\n  \"href\": \"link to current record\"\n}\n```\n\n\n\n#### Advanced Fromat (*)\n\nWe also provide the capability to use the complex syntax with * notation for more advanced requirement.\n\n|Format|Description|Example|\n|rel$relationship.attribute*|The attribute name from dynamic relationship (1:n)|rel$allwo.wonum*|\n|rel$relationship.exp$formula*|The formula for dynamic relationship (1:n)|rel$allwo.exp$formula*|\n|rel$relationship.relationship.attribute*|The attribute name from multiple level relationship (1:n)|rel$allwo.pm.pmnum*|\n|childobjectname.attribute*|The attribute name from child object (1:n)|location.location*|\n|exp$formula*|The formula for the object|exp$formula*|\n\nAssume we want to build the following clause\n\n```\noslc.select=rel.allwo{wonum,siteid,exp.formula,pm{pmnum,description}},location{location,description,allwo.wonum},assetnum,allwo.wonum\n```\n\nIt can be translated to x.y.z* syntax as following:\n\n```\nrel$allwo.wonum*\nrel$allwo.pm.description*\t\nassetnum\nrel$allwo.siteid*\t\nlocation.location*\nallwo.wonum\nrel$allwo.exp$formula*\nlocation.descrption*\nrel$allwo.pm.pmnum*\nlocation.allwo$wonum*\t\n```\n\n#### Differences between basic and advanced format\n\nIt is easy to get confused about syntax, let's take a deeper look at what's the differences among relName.AttrName, objName.attrName* and rel$relName.attrName*, taking MXAPIPO as an example and assume we need to deal with this relationship: Name = VENDOR, Parent = PO, Child = COMPANIES and we want to get the name of company.\n\nvendor.name: It's used to get the name of first company while we don't have companies defined as child object in MXAPIPO, it will only take the first record back even it could be one to many.\ncompanies.name*: It will convert to companies{name} by Query Template and used when we have COMPANIES as our child object in MXAPIPO (and relationship could be VENDOR), then we have to use objectname instead of relationship name to get the record back, and it will return multiple records if the result is one to many.\nrel$vendor.name*: It will convert to rel.vendor{name} by Query Template and used when we don't have COMPANIES as our child object in MXPO but we ant to get all records back if the result is one to many","fileAbsolutePath":"/home/travis/build/maximo-app-framework/maximo-restapi-documentation/src/pages/query/savedquery.mdx"}}},"staticQueryHashes":["1364590287","137577622","2102389209","2456312558","2746626797","3018647132","3037994772","768070550"]}