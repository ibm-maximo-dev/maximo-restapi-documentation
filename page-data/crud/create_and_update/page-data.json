{"componentChunkName":"component---src-pages-crud-create-and-update-mdx","path":"/crud/create_and_update/","result":{"pageContext":{"frontmatter":{"title":"Create and update resources"},"relativePagePath":"/crud/create_and_update.mdx","titleType":"append","MdxNode":{"id":"2786a0c9-bc14-5650-9375-a02d7db79678","children":[],"parent":"c1f8b7ff-90d2-5fa1-83a1-3ad066301d58","internal":{"content":"---\ntitle: Create and update resources\n---\n\n## Create resources\n\nCreating resources are almost always done using the collection uri - the same uri you would use to query the resources. For example the api call for creating assets is shown below.\n\n```\nPOST /oslc/os/mxapiasset\n```\n\nPost body:\n\n```json\n{\n  \"assetnum\": \"ASSET1\",\n  \"siteid\": \"BEDFORD\",\n  \"description\": \"my first asset\"\n}\n```\n\nOnce you create the asset, you will get a response that contains a location header with the URI of the newly created asset. You can now use that \"location\" uri to fetch the newly created resource. Rather than doing a GET to fetch the newly created resource, you may want the response of the create to contain your newly created resource. For that you can add the request header \"properties\". The properties header follows the syntax of the [oslc.select](../query/selecting) clause. You can use that to fetch all properties, partial set of properties, related mbo attributes, formula properties etc (everything that you can do with the select clause).\n\n```\nPOST /oslc/os/mxapiasset \nproperties: *\n\n{\n  \"assetnum\": \"ASSET1\",\n  \"siteid\": \"BEDFORD\",\n  \"description\": \"my first asset\"\n}\n```\n\nOR\n\n```\nPOST /oslc/os/mxapiasset \nproperties: assetnum,status\n\n{\n  \"assetnum\": \"ASSET1\",\n  \"siteid\": \"BEDFORD\",\n  \"description\": \"my first asset\"\n}\n```\n\nUsing this properties header, we can remove to the need to do an extra GET for every create/update.\n\n## Updating resources\n\nNow that we have created an asset, we will try to update it. For example, say we want to set a location and a description to the asset.\n\n```\nPOST /oslc/os/mxapiasset/{rest id for the asset} \nx-method-override: PATCH\nproperties:*\n\n{\n  \"location\": \"BR300\",\n  \"description\": \"test asset desc\"\n}\n```\n\nNote that the url we have a \"rest id..\" at the end of the collection url. This URI is pointing to a member asset in the collection - hence the \"rest id\" token after the collection uri. \n\n<InlineNotification kind=\"info\">\nThe rest id is not the unique id for the Mbo. It's a generated id for the Mbo that is created using the primary-key attribute values. \n</InlineNotification>\n\n<InlineNotification kind=\"info\">\nx-method-override:PATCH instructs the server side to update the resource. As with create, you can specify the properties request header, to get back the results of an update. The sample here shows a value of *. We would generally recommend avoiding use of * (unless you really want all properties) and instead use the selected set of properties that you care about (works our better for performance).\n</InlineNotification>\n\nNote that we needed to fetch the uri of the mxapiasset reasource in order to update it. Fetching of that URI can be done in 2 ways:\n- We can get the uri as part of a GET collection query which will return all select members with their uris.\n- As part of the response \"location\" header when we create a resource.\n\nAlthough this is the prevalent design for uri interaction in REST paradigm, in some cases you may not have the uri and still need to update the asset based on other key information. We will discuss how to do that shortly.\n\n\n## Add child objects\n\nNext let's try to add some child objects to this. For this example, we will add assetmeters to the newly creates asset. The api below adds 2 assetmeters to an asset:\n\n```\nPOST /oslc/os/mxapiasset/{rest id for the asset} \nx-method-override: PATCH\npatchtype: MERGE \nproperties:*\n```\n\nPost body:\n\n```json\n{\n  \"description\": \"test asset desc\",\n  \"assetmeter\": [\n    {\n      \"metername\": \"TEMP-F\",\n      \"linearassetid\": 0\n    },\n    {\n      \"metername\": \"ABC\",\n      \"linearassetid\": 0\n    }\n  ]\n}\n```\n\nNote that here we used an extra request header called patchtype with a value of MERGE. This instructs the server side to try to match the child objects - like assetmeter with the existing assetmters for this asset. If it finds a match, that assetmeter gets updates with the request assetmeter. If there is no match, it will create a new assetmeter. We call this the MERGE api.\n\nSay the asset to be updated had 3 existing assetmeters, and the request contained 1 existing assetmeter and 1 new assetmeter. After the merge call, that asset will be having 4 assetmeters - with one newly created one and another updated assetmeter.\n\nTo highlight the difference between a PATCH and MERGE call, we can run the same request but without the patchtype header, on another similar asset with 3 assetmeters. The server side will create a new assetmeter and update the existing assetmeter just as in the MERGE call.\n\nUnlike the MERGE call, it will end up deleting the assetmeters that were not in the request. In this example the asset with be left with only 2 assetmeters (that are in the request). Thus in PATCH request, the server side will delete all child objects that are not in the request payload.\n\n## Updating child objects\n\nNow let's talk about updating the child objects. In this example we will update the assetmeter object to set the meter reading. Make sure the MXAPIASSET Object structure has the np attributes \"newreading\" and \"newreadingdate\" included.\n\n```\nPOST /oslc/os/mxapiasset/{rest id for the asset} \nx-method-override: PATCH\npatchtype: MERGE \nproperties:*\n```\n\nPost body:\n\n```json\n{\n  \"description\": \"test asset desc - updating temp meter\",\n  \"assetmeter\": [\n    {\n      \"metername\": \"TEMP-F\",\n      \"linearassetid\": 0,\n      \"newreading\": \"10\"\n    }\n  ]\n}\n```\n\nNotice that we included the primary keys of the assetmeter - metername and linearassetid for the meter update. Another option that the api allows is to use the href uri for the assetmeter instead of the primary keys. The sample below shows that.\n\n```http\nPOST /oslc/os/mxapiasset/{rest id for the asset} \nx-method-override: PATCH\npatchtype: MERGE \nproperties:*\n\n{\n  \"description\": \"test asset desc - updating temp meter with child uri\",\n  \"assetmeter\": [\n    {\n      \"href\": \"parent uri#encoded_child_keys_anchored\",\n      \"newreading\": \"10\"\n    }\n  ]\n}\n```\n\n## Delete child objects\n\nIf you are wondering how to selectively delete child object, the request below shows just that.\n\n```\nPOST /oslc/os/mxapiasset/{rest id for the asset} \nx-method-override: PATCH\npatchtype: MERGE\nproperties:*\n\n{\n  \"assetmeter\": [\n    {\n      \"metername\": \"TEMP-F\",\n      \"linearassetid\": 0,\n      \"_action\": \"Delete\"\n    }\n  ]\n}\n```\n\nNote the use of child level actions (*_action*) to delete the assetmeter. You could have also used the child href instead of the primary keys as shown before. You could have also used the http DELETE method to delete the child object using the child object \"localuri\" URI.\n\n```\nDELETE <assetmeter localuri>\n```\n\nNote local uri for a child object (in Object Structure) is something you can use to refer directly to the child object. You cannot do the same with the child href as that is an anchored uri. For example you cannot use the child href for http DELETE.\n\n<InlineNotification kind=\"info\">\nUsing the POST method with the _action child action, you can do a bulk delete of child objects, which you cannot do using the http DELETE method.\n</InlineNotification>","type":"Mdx","contentDigest":"5e042af31215f375d40cd91610278d57","owner":"gatsby-plugin-mdx","counter":128},"frontmatter":{"title":"Create and update resources"},"exports":{},"rawBody":"---\ntitle: Create and update resources\n---\n\n## Create resources\n\nCreating resources are almost always done using the collection uri - the same uri you would use to query the resources. For example the api call for creating assets is shown below.\n\n```\nPOST /oslc/os/mxapiasset\n```\n\nPost body:\n\n```json\n{\n  \"assetnum\": \"ASSET1\",\n  \"siteid\": \"BEDFORD\",\n  \"description\": \"my first asset\"\n}\n```\n\nOnce you create the asset, you will get a response that contains a location header with the URI of the newly created asset. You can now use that \"location\" uri to fetch the newly created resource. Rather than doing a GET to fetch the newly created resource, you may want the response of the create to contain your newly created resource. For that you can add the request header \"properties\". The properties header follows the syntax of the [oslc.select](../query/selecting) clause. You can use that to fetch all properties, partial set of properties, related mbo attributes, formula properties etc (everything that you can do with the select clause).\n\n```\nPOST /oslc/os/mxapiasset \nproperties: *\n\n{\n  \"assetnum\": \"ASSET1\",\n  \"siteid\": \"BEDFORD\",\n  \"description\": \"my first asset\"\n}\n```\n\nOR\n\n```\nPOST /oslc/os/mxapiasset \nproperties: assetnum,status\n\n{\n  \"assetnum\": \"ASSET1\",\n  \"siteid\": \"BEDFORD\",\n  \"description\": \"my first asset\"\n}\n```\n\nUsing this properties header, we can remove to the need to do an extra GET for every create/update.\n\n## Updating resources\n\nNow that we have created an asset, we will try to update it. For example, say we want to set a location and a description to the asset.\n\n```\nPOST /oslc/os/mxapiasset/{rest id for the asset} \nx-method-override: PATCH\nproperties:*\n\n{\n  \"location\": \"BR300\",\n  \"description\": \"test asset desc\"\n}\n```\n\nNote that the url we have a \"rest id..\" at the end of the collection url. This URI is pointing to a member asset in the collection - hence the \"rest id\" token after the collection uri. \n\n<InlineNotification kind=\"info\">\nThe rest id is not the unique id for the Mbo. It's a generated id for the Mbo that is created using the primary-key attribute values. \n</InlineNotification>\n\n<InlineNotification kind=\"info\">\nx-method-override:PATCH instructs the server side to update the resource. As with create, you can specify the properties request header, to get back the results of an update. The sample here shows a value of *. We would generally recommend avoiding use of * (unless you really want all properties) and instead use the selected set of properties that you care about (works our better for performance).\n</InlineNotification>\n\nNote that we needed to fetch the uri of the mxapiasset reasource in order to update it. Fetching of that URI can be done in 2 ways:\n- We can get the uri as part of a GET collection query which will return all select members with their uris.\n- As part of the response \"location\" header when we create a resource.\n\nAlthough this is the prevalent design for uri interaction in REST paradigm, in some cases you may not have the uri and still need to update the asset based on other key information. We will discuss how to do that shortly.\n\n\n## Add child objects\n\nNext let's try to add some child objects to this. For this example, we will add assetmeters to the newly creates asset. The api below adds 2 assetmeters to an asset:\n\n```\nPOST /oslc/os/mxapiasset/{rest id for the asset} \nx-method-override: PATCH\npatchtype: MERGE \nproperties:*\n```\n\nPost body:\n\n```json\n{\n  \"description\": \"test asset desc\",\n  \"assetmeter\": [\n    {\n      \"metername\": \"TEMP-F\",\n      \"linearassetid\": 0\n    },\n    {\n      \"metername\": \"ABC\",\n      \"linearassetid\": 0\n    }\n  ]\n}\n```\n\nNote that here we used an extra request header called patchtype with a value of MERGE. This instructs the server side to try to match the child objects - like assetmeter with the existing assetmters for this asset. If it finds a match, that assetmeter gets updates with the request assetmeter. If there is no match, it will create a new assetmeter. We call this the MERGE api.\n\nSay the asset to be updated had 3 existing assetmeters, and the request contained 1 existing assetmeter and 1 new assetmeter. After the merge call, that asset will be having 4 assetmeters - with one newly created one and another updated assetmeter.\n\nTo highlight the difference between a PATCH and MERGE call, we can run the same request but without the patchtype header, on another similar asset with 3 assetmeters. The server side will create a new assetmeter and update the existing assetmeter just as in the MERGE call.\n\nUnlike the MERGE call, it will end up deleting the assetmeters that were not in the request. In this example the asset with be left with only 2 assetmeters (that are in the request). Thus in PATCH request, the server side will delete all child objects that are not in the request payload.\n\n## Updating child objects\n\nNow let's talk about updating the child objects. In this example we will update the assetmeter object to set the meter reading. Make sure the MXAPIASSET Object structure has the np attributes \"newreading\" and \"newreadingdate\" included.\n\n```\nPOST /oslc/os/mxapiasset/{rest id for the asset} \nx-method-override: PATCH\npatchtype: MERGE \nproperties:*\n```\n\nPost body:\n\n```json\n{\n  \"description\": \"test asset desc - updating temp meter\",\n  \"assetmeter\": [\n    {\n      \"metername\": \"TEMP-F\",\n      \"linearassetid\": 0,\n      \"newreading\": \"10\"\n    }\n  ]\n}\n```\n\nNotice that we included the primary keys of the assetmeter - metername and linearassetid for the meter update. Another option that the api allows is to use the href uri for the assetmeter instead of the primary keys. The sample below shows that.\n\n```http\nPOST /oslc/os/mxapiasset/{rest id for the asset} \nx-method-override: PATCH\npatchtype: MERGE \nproperties:*\n\n{\n  \"description\": \"test asset desc - updating temp meter with child uri\",\n  \"assetmeter\": [\n    {\n      \"href\": \"parent uri#encoded_child_keys_anchored\",\n      \"newreading\": \"10\"\n    }\n  ]\n}\n```\n\n## Delete child objects\n\nIf you are wondering how to selectively delete child object, the request below shows just that.\n\n```\nPOST /oslc/os/mxapiasset/{rest id for the asset} \nx-method-override: PATCH\npatchtype: MERGE\nproperties:*\n\n{\n  \"assetmeter\": [\n    {\n      \"metername\": \"TEMP-F\",\n      \"linearassetid\": 0,\n      \"_action\": \"Delete\"\n    }\n  ]\n}\n```\n\nNote the use of child level actions (*_action*) to delete the assetmeter. You could have also used the child href instead of the primary keys as shown before. You could have also used the http DELETE method to delete the child object using the child object \"localuri\" URI.\n\n```\nDELETE <assetmeter localuri>\n```\n\nNote local uri for a child object (in Object Structure) is something you can use to refer directly to the child object. You cannot do the same with the child href as that is an anchored uri. For example you cannot use the child href for http DELETE.\n\n<InlineNotification kind=\"info\">\nUsing the POST method with the _action child action, you can do a bulk delete of child objects, which you cannot do using the http DELETE method.\n</InlineNotification>","fileAbsolutePath":"/home/travis/build/maximo-app-framework/maximo-restapi-documentation/src/pages/crud/create_and_update.mdx"}}},"staticQueryHashes":["1364590287","137577622","2102389209","2456312558","2746626797","3018647132","3037994772","768070550"]}