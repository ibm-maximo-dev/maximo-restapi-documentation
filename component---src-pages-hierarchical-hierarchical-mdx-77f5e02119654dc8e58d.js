"use strict";(self.webpackChunkmas_playbook=self.webpackChunkmas_playbook||[]).push([[2004],{3624:function(e,t,a){a.d(t,{Z:function(){return v}});var o=a(7294),l=a(8650),r=a.n(l),n=a(1597),s=a(811),i=a(87),c=a(5900),h=a.n(c),d=function(e){var t,a=e.title,l=e.theme,r=e.tabs,n=void 0===r?[]:r;return o.createElement("div",{className:h()("PageHeader-module--page-header--NqfPe",(t={},t["PageHeader-module--with-tabs--vbQ-W"]=n.length,t["PageHeader-module--dark-mode--WCeH8"]="dark"===l,t))},o.createElement("div",{className:"bx--grid"},o.createElement("div",{className:"bx--row"},o.createElement("div",{className:"bx--col-lg-12"},o.createElement("h1",{id:"page-title",className:"PageHeader-module--text--Er2EO"},a)))))},m=function(e){var t=e.relativePagePath,a=e.repository,l=(0,n.useStaticQuery)("1364590287").site.siteMetadata.repository,r=a||l,s=r.baseUrl,i=r.subDirectory,c=s+"/edit/"+r.branch+i+"/src/pages"+t;return s?o.createElement("div",{className:"bx--row EditLink-module--row--BEmSX"},o.createElement("div",{className:"bx--col"},o.createElement("a",{className:"EditLink-module--link--IDrl1",href:c},"Edit this page on GitHub"))):null},p=a(4703),u=a(1721),g=function(e){function t(){return e.apply(this,arguments)||this}return(0,u.Z)(t,e),t.prototype.render=function(){var e=this.props,t=e.title,a=e.tabs,l=e.slug,s=l.split("/").filter(Boolean).slice(-1)[0],i=a.map((function(e){var t,a=r()(e,{lower:!0,strict:!0}),i=a===s,c=new RegExp(s+"/?(#.*)?$"),d=l.replace(c,a);return o.createElement("li",{key:e,className:h()((t={},t["PageTabs-module--selected-item--aBB0K"]=i,t),"PageTabs-module--list-item--024o6")},o.createElement(n.Link,{className:"PageTabs-module--link--Kz-7R",to:""+d},e))}));return o.createElement("div",{className:"PageTabs-module--tabs-container--Cdfzw"},o.createElement("div",{className:"bx--grid"},o.createElement("div",{className:"bx--row"},o.createElement("div",{className:"bx--col-lg-12 bx--col-no-gutter"},o.createElement("nav",{"aria-label":t},o.createElement("ul",{className:"PageTabs-module--list--xLqxG"},i))))))},t}(o.Component),f=g,w=a(7296),b=a(5387),y=a(3732),k=function(e){var t=e.date,a=new Date(t);return t?o.createElement(y.X2,{className:"last-modified-date-module--row--XJoYQ"},o.createElement(y.sg,null,o.createElement("div",{className:"last-modified-date-module--text--ogPQF"},"Page last updated: ",a.toLocaleDateString("en-GB",{day:"2-digit",year:"numeric",month:"long"})))):null},v=function(e){var t=e.pageContext,a=e.children,l=e.location,c=e.Title,h=t.frontmatter,u=void 0===h?{}:h,g=t.relativePagePath,y=t.titleType,v=u.tabs,E=u.title,T=u.theme,N=u.description,x=u.keywords,P=u.date,C=(0,b.Z)().interiorTheme,L=(0,n.useStaticQuery)("2456312558").site.pathPrefix,G=L?l.pathname.replace(L,""):l.pathname,j=v?G.split("/").filter(Boolean).slice(-1)[0]||r()(v[0],{lower:!0}):"",S=T||C;return o.createElement(i.Z,{tabs:v,homepage:!1,theme:S,pageTitle:E,pageDescription:N,pageKeywords:x,titleType:y},o.createElement(d,{title:c?o.createElement(c,null):E,label:"label",tabs:v,theme:S}),v&&o.createElement(f,{title:E,slug:G,tabs:v,currentTab:j}),o.createElement(w.Z,{padded:!0},a,o.createElement(m,{relativePagePath:g}),o.createElement(k,{date:P})),o.createElement(p.Z,{pageContext:t,location:l,slug:G,tabs:v,currentTab:j}),o.createElement(s.Z,null))}},6240:function(e,t,a){a.r(t),a.d(t,{_frontmatter:function(){return s},default:function(){return h}});var o=a(3366),l=(a(7294),a(4983)),r=a(3624),n=["components"],s={},i={_frontmatter:s},c=r.Z;function h(e){var t=e.components,a=(0,o.Z)(e,n);return(0,l.kt)(c,Object.assign({},i,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"Maximo has a lot of hierarchical objects - Locations, Workorders, Assets, Failure codes etc. There are subtle differences between each of these hierarchies and hence we would like to talk about each one of these separately."),(0,l.kt)("h2",null,"Location Hierarchy"),(0,l.kt)("p",null,"The location hierarchy in Maximo is always scoped under the LOCSYSTEM object. Effectively a given location can belong to multiple systems, and hence different hierarchies. The api is designed such a way that we start off with the list of systems that is available for the user. And then we dive into the hierarchy under the scope of that system."),(0,l.kt)("p",null,"We have an object structure - MXAPILOCSYSTEM that can be leveraged to get a list of systems. The api below shows how to do just that."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"GET /os/mxapilocsystem?oslc.select=systemid,description\n")),(0,l.kt)("p",null,"From there, we would like to go to the top (root) location under that system. You should select the system that you want to drill down using the href of the system record. The api call below shows how to do that."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"GET /os/mxapilocsystem/{id}/topleveloc.mxapioperloc?oslc.select=systemid,description\n")),(0,l.kt)("p",null,"Here ",(0,l.kt)("inlineCode",{parentName:"p"},"toplevelloc")," is the name of the relation from LOCSYSTEM to LOCATIONS table. Notice that we have appended that object structure name to the relation name to get the response as the MXAPIOPERLOC os. This helps us jump from one object structure to the other using the rest apis."),(0,l.kt)("p",null,"Next we would like to drill down under that top level location. For that we take the href of the location object that we got and append the relation name syschildren with the os name mxapioperloc appended to it (such that we stay in the context of the mxapioperloc os). The api for that is shown below"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"GET /os/mxapioperloc/{id}/syschildren.mxapioperloc?ctx=systemid=<systemid>\n")),(0,l.kt)("p",null,"You will also note that we used a query parameter ctx with the value of ",(0,l.kt)("inlineCode",{parentName:"p"},"systemid=<systemid of the system that we are drilling down into>"),". This is needed as a location can belong to multiple systems and hence multiple hierarchies. So while we drill down into the hierarchy, we need to provide the systemid context."),(0,l.kt)("p",null,"Now you can take any of the locations in the response and drill down by following the api described above. Always remember to set the ctx query parameter to the right systemid or else the api will default to the primary system for that location for the drill down."),(0,l.kt)("p",null,"You will also notice that these collection responses can be filtered, sorted or paged just like any other os query response. So if you are building a tree structure in the UI using these apis, you can introduce a sorting or filtering function at each tree node (which is a location)."),(0,l.kt)("h2",null,"General Ledger Component Hierarchies"),(0,l.kt)("p",null,"GL component hierarchies provides another flavor of Maximo hierarchies. The general ledger account consists of segments (gl components) which follow a certain hierarchy as defined in the chartofaccounts and glcomponents table. The glcomponents table defines all the components and their gl order. In order for an end user to specify a general ledger account we would need to provide an api for looking up the segments in a hierarchical way (following the gl order). The set of apis below describes just that."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"GET /oslc/glcomp?lean=1&oslc.select=*\n")),(0,l.kt)("p",null,"The response will be a list of gl segments at the top level ie gl order 0. For each of the records look for the childcompref uri. If we do a GET on that url we will get the child records for that segment. Note that the json also has a responseInfo that provides some metadata about the current segment ",(0,l.kt)("inlineCode",{parentName:"p"},"(glsegmentcurrent)")," as well as the total number of segments ",(0,l.kt)("inlineCode",{parentName:"p"},"(glsegmentcount)"),". The glcompsofar describes the account that has been selected so far. At the start it will just use the metacharacters ? (as configured) and the segment separators to represent the account. The GET on the childcompref would look like the api call below."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"GET /oslc/glcomp?glcomp=<comp0>&oslc.select=*\n")),(0,l.kt)("p",null,"The collection of records you get would be the next set of segments that are valid for the segments selected so far as described in the glcomp query parameter value. Note the glcomp query parameter value gets updated to point to the next set of segments as we drill down.\nInternally it uses the | separator for the segments and hence the childcompref url for the 3rd set of segments will look like"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"GET /oslc/glcomp?glcomp=<comp0|comp1>&oslc.select=*\n")),(0,l.kt)("p",null,"You can instead also specify the glcompsofar value to drill down too. The sample api call below shows how to do that."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"GET /oslc/glcomp?glvalue=<comp0-comp1-???>&oslc.select=*\n")),(0,l.kt)("p",null,"Note the use of glvalue query parameter to get the values. This will give the exact same results as the ",(0,l.kt)("inlineCode",{parentName:"p"},"glcomp=comp0|comp1")," api call."),(0,l.kt)("p",null,"As is the case with the other hierarchies, we can sort ",(0,l.kt)("inlineCode",{parentName:"p"},"(oslc.orderBy)")," and filter ",(0,l.kt)("inlineCode",{parentName:"p"},"(oslc.where)")," with these apis."))}h.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-hierarchical-hierarchical-mdx-77f5e02119654dc8e58d.js.map