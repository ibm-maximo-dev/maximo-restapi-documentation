"use strict";(self.webpackChunkmas_playbook=self.webpackChunkmas_playbook||[]).push([[6225],{3624:function(e,t,n){n.d(t,{Z:function(){return y}});var o=n(7294),a=n(8650),i=n.n(a),l=n(1597),s=n(811),r=n(87),h=n(5900),c=n.n(h),d=function(e){var t,n=e.title,a=e.theme,i=e.tabs,l=void 0===i?[]:i;return o.createElement("div",{className:c()("PageHeader-module--page-header--NqfPe",(t={},t["PageHeader-module--with-tabs--vbQ-W"]=l.length,t["PageHeader-module--dark-mode--WCeH8"]="dark"===a,t))},o.createElement("div",{className:"bx--grid"},o.createElement("div",{className:"bx--row"},o.createElement("div",{className:"bx--col-lg-12"},o.createElement("h1",{id:"page-title",className:"PageHeader-module--text--Er2EO"},n)))))},p=function(e){var t=e.relativePagePath,n=e.repository,a=(0,l.useStaticQuery)("1364590287").site.siteMetadata.repository,i=n||a,s=i.baseUrl,r=i.subDirectory,h=s+"/edit/"+i.branch+r+"/src/pages"+t;return s?o.createElement("div",{className:"bx--row EditLink-module--row--BEmSX"},o.createElement("div",{className:"bx--col"},o.createElement("a",{className:"EditLink-module--link--IDrl1",href:h},"Edit this page on GitHub"))):null},m=n(4703),u=n(1721),k=function(e){function t(){return e.apply(this,arguments)||this}return(0,u.Z)(t,e),t.prototype.render=function(){var e=this.props,t=e.title,n=e.tabs,a=e.slug,s=a.split("/").filter(Boolean).slice(-1)[0],r=n.map((function(e){var t,n=i()(e,{lower:!0,strict:!0}),r=n===s,h=new RegExp(s+"/?(#.*)?$"),d=a.replace(h,n);return o.createElement("li",{key:e,className:c()((t={},t["PageTabs-module--selected-item--aBB0K"]=r,t),"PageTabs-module--list-item--024o6")},o.createElement(l.Link,{className:"PageTabs-module--link--Kz-7R",to:""+d},e))}));return o.createElement("div",{className:"PageTabs-module--tabs-container--Cdfzw"},o.createElement("div",{className:"bx--grid"},o.createElement("div",{className:"bx--row"},o.createElement("div",{className:"bx--col-lg-12 bx--col-no-gutter"},o.createElement("nav",{"aria-label":t},o.createElement("ul",{className:"PageTabs-module--list--xLqxG"},r))))))},t}(o.Component),w=k,f=n(7296),g=n(5387),v=n(3732),b=function(e){var t=e.date,n=new Date(t);return t?o.createElement(v.X2,{className:"last-modified-date-module--row--XJoYQ"},o.createElement(v.sg,null,o.createElement("div",{className:"last-modified-date-module--text--ogPQF"},"Page last updated: ",n.toLocaleDateString("en-GB",{day:"2-digit",year:"numeric",month:"long"})))):null},y=function(e){var t=e.pageContext,n=e.children,a=e.location,h=e.Title,c=t.frontmatter,u=void 0===c?{}:c,k=t.relativePagePath,v=t.titleType,y=u.tabs,N=u.title,T=u.theme,E=u.description,x=u.keywords,P=u.date,I=(0,g.Z)().interiorTheme,j=(0,l.useStaticQuery)("2456312558").site.pathPrefix,C=j?a.pathname.replace(j,""):a.pathname,H=y?C.split("/").filter(Boolean).slice(-1)[0]||i()(y[0],{lower:!0}):"",S=T||I;return o.createElement(r.Z,{tabs:y,homepage:!1,theme:S,pageTitle:N,pageDescription:E,pageKeywords:x,titleType:v},o.createElement(d,{title:h?o.createElement(h,null):N,label:"label",tabs:y,theme:S}),y&&o.createElement(w,{title:N,slug:C,tabs:y,currentTab:H}),o.createElement(f.Z,{padded:!0},n,o.createElement(p,{relativePagePath:k}),o.createElement(b,{date:P})),o.createElement(m.Z,{pageContext:t,location:a,slug:C,tabs:y,currentTab:H}),o.createElement(s.Z,null))}},1713:function(e,t,n){n.r(t),n.d(t,{_frontmatter:function(){return s},default:function(){return c}});var o=n(3366),a=(n(7294),n(4983)),i=n(3624),l=["components"],s={},r={_frontmatter:s},h=i.Z;function c(e){var t=e.components,n=(0,o.Z)(e,l);return(0,a.kt)(h,Object.assign({},r,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Initiating a workflow for a given Mbo can be done by using the api shown below:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"POST /oslc/os/<os name>/{rest id}?action=workflow:<workflow name> \nx-method-override: PATCH\n")),(0,a.kt)("p",null,"This will invoke the named workflow in the context of the mbo identified in the URI."),(0,a.kt)("h2",null,"Handling Task Nodes"),(0,a.kt)("p",null,"After initiation the workflow might end up into a task node, which generates an assignment. The apis below shows how you can handle assignments."),(0,a.kt)("p",null,"The first step would be for the user to fetch his/her assignments. For an user to fetch assignments use the api below"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"GET /oslc/os/mxapiwfassignment?oslc.select=*\n")),(0,a.kt)("p",null,"This will fetch all the assignments for that user. Each assignment will have a positive action and a negative action to take.\nThe sample json is shown below"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "description": "mydesc",\n    "wfassignmentid": "myid",\n    "href": "http://myhref",\n    "wfaction": [\n      {\n        "instruction": "myinstruction1",\n        "ispositive": false\n      },\n      {\n        "instruction": "myinstruction2",\n        "ispositive": true\n      }\n    ]\n  }\n  ...\n]\n')),(0,a.kt)("p",null,"Note that the wfaction json contains the positive and negative actions. The user is supposed to take up one or the other."),(0,a.kt)("p",null,"The api call below shows how to take the positive action."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"POST /oslc/os/mxapiwfassignment/{id}?action=wsmethod:completeAssignment \nx-method-override: PATCH\n")),(0,a.kt)("p",null,"Body:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "memo": "some memo",\n  "accepted": true\n}\n')),(0,a.kt)("p",null,"To take up the negative route you can just set the accepted flag to false in the json and POST to the same href."),(0,a.kt)("h2",null,"Handling Input Nodes"),(0,a.kt)("p",null,"Input nodes provide the user with interactive options to choose from in a workflow path. The user may not choose anything, in which case the workflow stays in that same state. If the workflow framework looks ahead and sees an input node as the next node, the rest api response for the current node (say that was a task assignment that the user accepted or rejected) will return"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"A response json which will have the details of the options that the input node provides. The consuming client code is supposed to use those options to let the end user decide the option to chose."),(0,a.kt)("li",{parentName:"ol"},"A response location header with the url to POST the users choice to.")),(0,a.kt)("p",null,"The response json may look like this"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "member": [\n    {\n      "actionid": "myactionid1",\n      "instruction": "myinstruction1"\n    },\n    {\n      "actionid": "myactionid2",\n      "instruction": "myinstruction2"\n    }\n  ],\n  "nodetype": "INPUT",\n  "internalnodetype": "WFINPUT"\n}\n')),(0,a.kt)("p",null,"Note that the input node type says that its ",(0,a.kt)("inlineCode",{parentName:"p"},"WFINPUT"),". This information can be leveraged by the consuming code (say a mobile app) to display a generic UI to represent these options."),(0,a.kt)("p",null,"The api call below describes how to choose an option: "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"POST <location uri>\n")),(0,a.kt)("p",null,"Body:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "actionid": "choose one of the action id from the json above",\n  "memo": "some memo"\n}\n')),(0,a.kt)("p",null,"Note if this call is not made, the workflow stays with the current node (ie the node previous to the input node) and does not move to the next node. In essence the input node is a transient node which is only available for processing within that context of the previous node."),(0,a.kt)("h2",null,"Handling Interaction Nodes"),(0,a.kt)("p",null,"Interaction nodes are Maximo UI dialogs and applications/tabs that are presented to the user for him/her to take an action using that UI artifact. Now unlike an input node this one is not a transient node. This implies that the workflow engine has moved to the this node from the previous node."),(0,a.kt)("p",null,"When the workflow lands into this node, the response json from the previous call should indicate that details of the interaction node, presenting the information from the WFINTERACTION table for that node. This should help identify (using the json property ",(0,a.kt)("inlineCode",{parentName:"p"},"internalnodetype")," with a value of WFINTERACTION ) the client code to provide an equivalent interface for the Maximo dialog/app for the user to act upon. Like the case with the input node, the rest framework will generate a URI (set the in the response location header) for the client code to respond back to the interaction such that the workflow instance can move to the next node in the path."),(0,a.kt)("p",null,"Now if the user ignores this node the engine just moves on to the next node. But the engine needs to know that the interaction node job is complete one way or the other. To do that the end user in Maximo application will re-route the workflow by pressing the workflow route button. To simulate that in the api realm, the client code needs to make the api call shown below"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"POST <location uri>\n")),(0,a.kt)("p",null,"Body:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "interactioncomplete": 1\n}\n')),(0,a.kt)("p",null,"This will indicate to the workflow engine that the interaction is complete."),(0,a.kt)("h2",null,"Handling Wait Nodes"),(0,a.kt)("p",null,"Wait nodes are listeners to the Mbo (that is being workflowed) event. Effectively the workflow waits on this event and when the event eventually happens, it moves to the next node. We do not need any special handling with apis for this node as this is backend event driven. So if an event comes from any api calls/ MIF call or UI call - for that mbo, the workflow will listen for that and if the condition is met, it will move to the next node in the path."),(0,a.kt)("h2",null,"Handling Condition Nodes"),(0,a.kt)("p",null,"Condition nodes are automatically evaluated by the workflow engine and the engine will move to the next node in the path after condition evaluation."))}c.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-workflow-workflow-mdx-fdc55145eb9d15d28a82.js.map