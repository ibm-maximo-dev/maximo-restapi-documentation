"use strict";(self.webpackChunkmas_playbook=self.webpackChunkmas_playbook||[]).push([[8163],{3624:function(e,t,a){a.d(t,{Z:function(){return y}});var n=a(7294),l=a(8650),r=a.n(l),o=a(1597),i=a(811),s=a(87),u=a(5900),d=a.n(u),c=function(e){var t,a=e.title,l=e.theme,r=e.tabs,o=void 0===r?[]:r;return n.createElement("div",{className:d()("PageHeader-module--page-header--NqfPe",(t={},t["PageHeader-module--with-tabs--vbQ-W"]=o.length,t["PageHeader-module--dark-mode--WCeH8"]="dark"===l,t))},n.createElement("div",{className:"bx--grid"},n.createElement("div",{className:"bx--row"},n.createElement("div",{className:"bx--col-lg-12"},n.createElement("h1",{id:"page-title",className:"PageHeader-module--text--Er2EO"},a)))))},p=function(e){var t=e.relativePagePath,a=e.repository,l=(0,o.useStaticQuery)("1364590287").site.siteMetadata.repository,r=a||l,i=r.baseUrl,s=r.subDirectory,u=i+"/edit/"+r.branch+s+"/src/pages"+t;return i?n.createElement("div",{className:"bx--row EditLink-module--row--BEmSX"},n.createElement("div",{className:"bx--col"},n.createElement("a",{className:"EditLink-module--link--IDrl1",href:u},"Edit this page on GitHub"))):null},h=a(4703),m=a(1721),k=function(e){function t(){return e.apply(this,arguments)||this}return(0,m.Z)(t,e),t.prototype.render=function(){var e=this.props,t=e.title,a=e.tabs,l=e.slug,i=l.split("/").filter(Boolean).slice(-1)[0],s=a.map((function(e){var t,a=r()(e,{lower:!0,strict:!0}),s=a===i,u=new RegExp(i+"/?(#.*)?$"),c=l.replace(u,a);return n.createElement("li",{key:e,className:d()((t={},t["PageTabs-module--selected-item--aBB0K"]=s,t),"PageTabs-module--list-item--024o6")},n.createElement(o.Link,{className:"PageTabs-module--link--Kz-7R",to:""+c},e))}));return n.createElement("div",{className:"PageTabs-module--tabs-container--Cdfzw"},n.createElement("div",{className:"bx--grid"},n.createElement("div",{className:"bx--row"},n.createElement("div",{className:"bx--col-lg-12 bx--col-no-gutter"},n.createElement("nav",{"aria-label":t},n.createElement("ul",{className:"PageTabs-module--list--xLqxG"},s))))))},t}(n.Component),w=k,b=a(7296),g=a(5387),f=a(3732),N=function(e){var t=e.date,a=new Date(t);return t?n.createElement(f.X2,{className:"last-modified-date-module--row--XJoYQ"},n.createElement(f.sg,null,n.createElement("div",{className:"last-modified-date-module--text--ogPQF"},"Page last updated: ",a.toLocaleDateString("en-GB",{day:"2-digit",year:"numeric",month:"long"})))):null},y=function(e){var t=e.pageContext,a=e.children,l=e.location,u=e.Title,d=t.frontmatter,m=void 0===d?{}:d,k=t.relativePagePath,f=t.titleType,y=m.tabs,E=m.title,T=m.theme,v=m.description,P=m.keywords,x=m.date,A=(0,g.Z)().interiorTheme,S=(0,o.useStaticQuery)("2456312558").site.pathPrefix,q=S?l.pathname.replace(S,""):l.pathname,I=y?q.split("/").filter(Boolean).slice(-1)[0]||r()(y[0],{lower:!0}):"",C=T||A;return n.createElement(s.Z,{tabs:y,homepage:!1,theme:C,pageTitle:E,pageDescription:v,pageKeywords:P,titleType:f},n.createElement(c,{title:u?n.createElement(u,null):E,label:"label",tabs:y,theme:C}),y&&n.createElement(w,{title:E,slug:q,tabs:y,currentTab:I}),n.createElement(b.Z,{padded:!0},a,n.createElement(p,{relativePagePath:k}),n.createElement(N,{date:x})),n.createElement(h.Z,{pageContext:t,location:l,slug:q,tabs:y,currentTab:I}),n.createElement(i.Z,null))}},244:function(e,t,a){a.r(t),a.d(t,{_frontmatter:function(){return i},default:function(){return d}});var n=a(3366),l=(a(7294),a(4983)),r=a(3624),o=["components"],i={},s={_frontmatter:i},u=r.Z;function d(e){var t=e.components,a=(0,n.Z)(e,o);return(0,l.kt)(u,Object.assign({},s,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h2",null,"Where Filters - oslc.where"),(0,l.kt)("p",null,"The most common way to filter a resource set is to use the oslc.where query parameter. This internally maps to the Maximo Qbe framework. We can filter data based on all persistent attributes - at the main mbo (for the os) or any related mbo. For example the where clause below would filter assets based on locations and asset status."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'GET /oslc/os/mxapiasset?oslc.where=status="OPERATING" and location.status="OPERATING"&lean=1\n')),(0,l.kt)("p",null,"Note here the Locations Mbo is not part of the MXAPIASSET Object Structure. The format for the dot notation (location.status) is ",(0,l.kt)("inlineCode",{parentName:"p"},"<rel1>[.rel2]*.attr1"),". As you can make out, the dot notation can be deeply nested. The leaf element is always an attribute in the target Mbo."),(0,l.kt)("p",null,"Before we dive too much into nested queries, let’s just look at the different operators."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Operator"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Usage"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"="),(0,l.kt)("td",{parentName:"tr",align:null},"equals"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},'status="APPR"'))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},">="),(0,l.kt)("td",{parentName:"tr",align:null},"Greater than equals"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"priority>=1"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},">"),(0,l.kt)("td",{parentName:"tr",align:null},"Greater than"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},'startdate>"iso date"'))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"<"),(0,l.kt)("td",{parentName:"tr",align:null},"Less than"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},'startdate<"iso date"'))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"<="),(0,l.kt)("td",{parentName:"tr",align:null},"Less than equals"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"linecost<=200.5"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"!="),(0,l.kt)("td",{parentName:"tr",align:null},"Not equals"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"priority!=2"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"in"),(0,l.kt)("td",{parentName:"tr",align:null},"In clause"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},'location in ["A","B","C"], priority in [1,2,3]'))))),(0,l.kt)("p",null,'This query language is data type sensitive and we would use the double quotes "" for character based attributes and for dates (ISO Format). Numeric values are represented in their corresponding ISO formats (ie non localized format). Boolean values are always represented either as 1/0 or true/false (no quotes)'),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'oslc.where=status in ["OPERATING","ACTIVE"] and priority=3 and statusdate>"ISO date string" and linear=false\n')),(0,l.kt)("p",null,"We can do in clause with numeric values too."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"oslc.where=priority in [1,2,3]\n")),(0,l.kt)("p",null,"To do like clause you can do the following variations."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'oslc.where=status="%APPR%"\n')),(0,l.kt)("p",null,"If we want to do starts with"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'oslc.where=status="APPR%"\n')),(0,l.kt)("p",null,"If we want to do ends with "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'oslc.where=status="%APPR"\n')),(0,l.kt)("p",null,"For doing null value queries we can use the star (*) notation as below. For example a not null check can be done using the following format where - status is not null."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'oslc.where=status="*"\n')),(0,l.kt)("p",null,"If we wanted to do the is null check:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'oslc.where=status!="*"\n')),(0,l.kt)("p",null,"We have already shown a sample of the in clause. If we want to do a not in clause - use the format below."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'location!= "[BR300,BR400]"\n')),(0,l.kt)("p",null,"Note that this not in clause currently only works for ALN attributes."),(0,l.kt)("h2",null,"Range Filters"),(0,l.kt)("p",null,"These are used for supporting range based queries. For example if we want to only get assets in certain date range and priority range we can use this feature."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'oslc.where=priority>1 and priority<=3 and installdate>="1999-02-06T00:00:00-05:00" and installdate<"2009-02-06T00:00:00-05:00"\n')),(0,l.kt)("p",null,"The date ranges can be easier done with timeline queries which we will cover in a few sections."),(0,l.kt)("h2",null,"SynonymDomain Internal Filters"),(0,l.kt)("p",null,"We can also filter using the internal values for synonymdomains. The sample below shows how we can use that to filter the workorder objects based on the internal values for the status attribute (bound to the WOSTATUS synonymdomain)."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"GET <collection uri>?oslc.where=...&domaininternalwhere=status!=APPR,INPRG\n")),(0,l.kt)("p",null,"This will filter the workorder collection using the “not in” clause for the set of external values corresponding to the internal values of APPR and INPRG. We can use a “in” comparison by changing the expression like below:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"GET <collection uri>?oslc.where=...&domaininternalwhere=status=APPR,INPRG\n")),(0,l.kt)("p",null,"Few things to note here:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The domaininternalwhere query parameter is independent of the oslc.where and is “anded” to the oslc.where clause (if oslc.where is present in the request)."),(0,l.kt)("li",{parentName:"ul"},"The format is ",(0,l.kt)("inlineCode",{parentName:"li"},"<attr name>[=/!=]internal_val1,internal_val2,...")),(0,l.kt)("li",{parentName:"ul"},"This feature always generates a sql with “in” or a “not in” operator depending on whether the = or != operator was used."),(0,l.kt)("li",{parentName:"ul"},"The list of internal values need to be comma delimited."),(0,l.kt)("li",{parentName:"ul"},"There can be one or many internal values and null is not allowed in this value set.")),(0,l.kt)("h2",null,"MaxTableDomain Based Filters"),(0,l.kt)("p",null,"We can also filter using the maxtabledomain list where clause. This is there more for backward compatibility reasons with the older rest api and in case a client wants to leverage an existing list where clause already created using the table-domain.. The api syntax is shown here."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"GET <collection uri>?_fd=<maxtabledomain name>&_fdsite=<siteid>&_fdorg=<orgid>\n")),(0,l.kt)("p",null,"This picks up the domains listwhere and applies that to the collection. The site and org are optional and needed if the maxtabledomain is site/org scoped."),(0,l.kt)("h2",null,"Timeline Filters"),(0,l.kt)("p",null,"The timeline filters allow a simpler way to filter collections with time range based queries. An example below shows how we can get all workorders reported in the past 3 months"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"GET /oslc/os/mxapiwodetail?tlrange=-3M&tlattribute=reportdate\n")),(0,l.kt)("p",null,"This will simply find all the workorders with a reportdate between today and and 3 months back. The query is by default indexed around the current date. Another variation of this query would be to range on a future date just by switching the sign on the tlrange to say +3M instead of -3M. For reportdate a future date range may not be good use case, but it would for date attributes like scheduled date etc (which can be in future). You might also use the current date as an index and filter around that date using the +- notation like below"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"&tlrange=+-3Y\n")),(0,l.kt)("p",null,"This will filter records 3 years past and 3 years to the future indexed on the current date. If current date is not what we want to index on, we can specify the date that we want to use for the index as shown below"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"&tlattribute=reportdate=<some iso date>\n")),(0,l.kt)("h2",null,"Classification Attribute Search"),(0,l.kt)("p",null,"Maximo objects like Assets, Locations, Items, Workorders etc can be associated with classifications which provides a way to associate classification metadata (aka classification attributes) to the said objects. Maximo allows searching those objects (assets,locations etc) based on those attribute values. This search capability is what we call as Attribute Search feature.\nA sample below describes an attribute search applied to the Asset Mbo using the MXAPIASSET Object Structure."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"GET oslc/os/mxapiasset?attributesearch=[SPEED:>=50]\n")),(0,l.kt)("p",null,"This searches for all assets that have a class spec attribute called SPEED with a value >=50. If we did not set that :>=50 and run the query as:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"GET oslc/os/mxapiasset?attributesearch=[SPEED]\n")),(0,l.kt)("p",null,"It would have only fetched assets that have SPEED as a spec attribute. For combining multiple attributes together in the search follow the example below:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"GET oslc/os/mxapiasset?attributesearch=[SPEED:>=50;AREA;ELEV:=300]\n")),(0,l.kt)("p",null,"This will search for assets that have a class spec attribute SPEED with a value greater than 50 and an attribute named AREA and attribute name ELEV with a value of 300, all and-ed together."),(0,l.kt)("p",null,"Note this feature is in addition to the oslc.where/savedquery query parameter. So you can use this feature along with the other filtering capabilities that are supported in this api framework."))}d.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-query-filtering-mdx-4cff3972f45d5d2ef4f9.js.map