"use strict";(self.webpackChunkmas_playbook=self.webpackChunkmas_playbook||[]).push([[8163],{3624:function(e,t,a){a.d(t,{Z:function(){return y}});var n=a(7294),r=a(8650),l=a.n(r),i=a(1597),o=a(811),s=a(87),u=a(5900),d=a.n(u),p=function(e){var t,a=e.title,r=e.theme,l=e.tabs,i=void 0===l?[]:l;return n.createElement("div",{className:d()("PageHeader-module--page-header--NqfPe",(t={},t["PageHeader-module--with-tabs--vbQ-W"]=i.length,t["PageHeader-module--dark-mode--WCeH8"]="dark"===r,t))},n.createElement("div",{className:"bx--grid"},n.createElement("div",{className:"bx--row"},n.createElement("div",{className:"bx--col-lg-12"},n.createElement("h1",{id:"page-title",className:"PageHeader-module--text--Er2EO"},a)))))},m=function(e){var t=e.relativePagePath,a=e.repository,r=(0,i.useStaticQuery)("1364590287").site.siteMetadata.repository,l=a||r,o=l.baseUrl,s=l.subDirectory,u=o+"/edit/"+l.branch+s+"/src/pages"+t;return o?n.createElement("div",{className:"bx--row EditLink-module--row--BEmSX"},n.createElement("div",{className:"bx--col"},n.createElement("a",{className:"EditLink-module--link--IDrl1",href:u},"Edit this page on GitHub"))):null},c=a(4703),h=a(1721),k=function(e){function t(){return e.apply(this,arguments)||this}return(0,h.Z)(t,e),t.prototype.render=function(){var e=this.props,t=e.title,a=e.tabs,r=e.slug,o=r.split("/").filter(Boolean).slice(-1)[0],s=a.map((function(e){var t,a=l()(e,{lower:!0,strict:!0}),s=a===o,u=new RegExp(o+"/?(#.*)?$"),p=r.replace(u,a);return n.createElement("li",{key:e,className:d()((t={},t["PageTabs-module--selected-item--aBB0K"]=s,t),"PageTabs-module--list-item--024o6")},n.createElement(i.Link,{className:"PageTabs-module--link--Kz-7R",to:""+p},e))}));return n.createElement("div",{className:"PageTabs-module--tabs-container--Cdfzw"},n.createElement("div",{className:"bx--grid"},n.createElement("div",{className:"bx--row"},n.createElement("div",{className:"bx--col-lg-12 bx--col-no-gutter"},n.createElement("nav",{"aria-label":t},n.createElement("ul",{className:"PageTabs-module--list--xLqxG"},s))))))},t}(n.Component),N=k,f=a(7296),g=a(5387),b=a(3732),w=function(e){var t=e.date,a=new Date(t);return t?n.createElement(b.X2,{className:"last-modified-date-module--row--XJoYQ"},n.createElement(b.sg,null,n.createElement("div",{className:"last-modified-date-module--text--ogPQF"},"Page last updated: ",a.toLocaleDateString("en-GB",{day:"2-digit",year:"numeric",month:"long"})))):null},y=function(e){var t=e.pageContext,a=e.children,r=e.location,u=e.Title,d=t.frontmatter,h=void 0===d?{}:d,k=t.relativePagePath,b=t.titleType,y=h.tabs,E=h.title,T=h.theme,v=h.description,C=h.keywords,P=h.date,x=(0,g.Z)().interiorTheme,A=(0,i.useStaticQuery)("2456312558").site.pathPrefix,I=A?r.pathname.replace(A,""):r.pathname,S=y?I.split("/").filter(Boolean).slice(-1)[0]||l()(y[0],{lower:!0}):"",q=T||x;return n.createElement(s.Z,{tabs:y,homepage:!1,theme:q,pageTitle:E,pageDescription:v,pageKeywords:C,titleType:b},n.createElement(p,{title:u?n.createElement(u,null):E,label:"label",tabs:y,theme:q}),y&&n.createElement(N,{title:E,slug:I,tabs:y,currentTab:S}),n.createElement(f.Z,{padded:!0},a,n.createElement(m,{relativePagePath:k}),n.createElement(w,{date:P})),n.createElement(c.Z,{pageContext:t,location:r,slug:I,tabs:y,currentTab:S}),n.createElement(o.Z,null))}},244:function(e,t,a){a.r(t),a.d(t,{_frontmatter:function(){return o},default:function(){return d}});var n=a(3366),r=(a(7294),a(4983)),l=a(3624),i=["components"],o={},s={_frontmatter:o},u=l.Z;function d(e){var t=e.components,a=(0,n.Z)(e,i);return(0,r.kt)(u,Object.assign({},s,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",null,"Where Filters - oslc.where"),(0,r.kt)("p",null,"The most common way to filter a resource set is to use the  ",(0,r.kt)("inlineCode",{parentName:"p"},"oslc.where")," query parameter. This parameter internally maps to the Maximo QBE framework. You can filter data that is based on all persistent attributes, at the main MBO (for the OS) or any related MBO. In the example, the ",(0,r.kt)("inlineCode",{parentName:"p"},"where clause")," filters assets that are based on locations and the asset status."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'GET /oslc/os/mxapiasset?oslc.where=status="OPERATING" and location.status="OPERATING"&lean=1\n')),(0,r.kt)("p",null,"The locations MBO is not part of the MXAPIASSET object structure. The format for the dot notation (",(0,r.kt)("inlineCode",{parentName:"p"},"location.status"),") is  ",(0,r.kt)("inlineCode",{parentName:"p"},"<rel1>[.rel2]*.attr1"),". As you can make out, the dot notation can be nested. The leaf element is always an attribute in the target Mbo."),(0,r.kt)("p",null,"The following table describes the different operators that you can use for filtering data:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Operator"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Usage"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"="),(0,r.kt)("td",{parentName:"tr",align:null},"equals"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'status="APPR"'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},">="),(0,r.kt)("td",{parentName:"tr",align:null},"Greater than equals"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"priority>=1"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},">"),(0,r.kt)("td",{parentName:"tr",align:null},"Greater than"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'startdate>"iso date"'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"<"),(0,r.kt)("td",{parentName:"tr",align:null},"Less than"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'startdate<"iso date"'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"<="),(0,r.kt)("td",{parentName:"tr",align:null},"Less than equals"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"linecost<=200.5"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"!="),(0,r.kt)("td",{parentName:"tr",align:null},"Not equals"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"priority!=2"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"in"),(0,r.kt)("td",{parentName:"tr",align:null},"In clause"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'location in ["A","B","C"], priority in [1,2,3]'))))),(0,r.kt)("p",null,"This query language is data type sensitive and the double quotes  ",(0,r.kt)("inlineCode",{parentName:"p"},'""')," is used for character based attributes and for dates (ISO Format). Numeric values are represented in their corresponding ISO formats (that is non localized format). Boolean values are always represented either as ",(0,r.kt)("inlineCode",{parentName:"p"},"1/0"),"  or ",(0,r.kt)("inlineCode",{parentName:"p"},"true/false")," (no quotes)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'oslc.where=status in ["OPERATING","ACTIVE"] and priority=3 and statusdate>"ISO date string" and linear=false\n')),(0,r.kt)("p",null,"You can use the in clause with numeric values too."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"oslc.where=priority in [1,2,3]\n")),(0,r.kt)("p",null,"For the LIKE clause, you can use the following variations:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'oslc.where=status="%APPR%"\n')),(0,r.kt)("p",null,"If you want to use starts with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'oslc.where=status="APPR%"\n')),(0,r.kt)("p",null,"If you want to use ends with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'oslc.where=status="%APPR"\n')),(0,r.kt)("p",null,"To use null value queries,  you can use the star (*) notation. For example, a not null check is completed by using the following format where - ",(0,r.kt)("inlineCode",{parentName:"p"},"status is not null"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'oslc.where=status="*"\n')),(0,r.kt)("p",null,"If you want to use the is null check:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'oslc.where=status!="*"\n')),(0,r.kt)("p",null,"If you want to use a not in clause, you can use the following format:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'location!= "[BR300,BR400]"\n')),(0,r.kt)("p",null,"Note that this not in clause currently only works for ALN attributes."),(0,r.kt)("h2",null,"Range Filters"),(0,r.kt)("p",null,"Range filters are used to support range based queries. For example, if you want to only get assets within a certain date range and priority range, you can use this feature."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'oslc.where=priority>1 and priority<=3 and installdate>="1999-02-06T00:00:00-05:00" and installdate<"2009-02-06T00:00:00-05:00"\n')),(0,r.kt)("p",null,"You can also filter with date ranges by using timeline queries."),(0,r.kt)("h2",null,"SynonymDomain Internal Filters"),(0,r.kt)("p",null,"You can also filter by using the internal values for synonymdomains. The following example shows how you can filter the work order objects that are based on the internal values for the status attribute (bound to the WOSTATUS synonymdomain)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"GET <collection uri>?oslc.where=...&domaininternalwhere=status!=APPR,INPRG\n")),(0,r.kt)("p",null,"This will filter the work order collection using the ",(0,r.kt)("strong",{parentName:"p"},"not in")," clause for the set of external values that correspond to the internal values of ",(0,r.kt)("inlineCode",{parentName:"p"},"APPR")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"INPRG"),". We can use a ",(0,r.kt)("inlineCode",{parentName:"p"},"in")," comparison by changing the expression like below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"GET <collection uri>?oslc.where=...&domaininternalwhere=status=APPR,INPRG\n")),(0,r.kt)("p",null,"There are a few things to note:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"domaininternalwhere")," query parameter is independent of the ",(0,r.kt)("inlineCode",{parentName:"li"},"oslc.where")," and is ",(0,r.kt)("inlineCode",{parentName:"li"},"ANDed")," to the ",(0,r.kt)("inlineCode",{parentName:"li"},"oslc.where ")," clause (if ",(0,r.kt)("inlineCode",{parentName:"li"},"oslc.where")," is present in the request)."),(0,r.kt)("li",{parentName:"ul"},"The format is ",(0,r.kt)("inlineCode",{parentName:"li"},"<attr name>[=/!=]internal_val1,internal_val2,...")),(0,r.kt)("li",{parentName:"ul"},"This feature always generates an SQL with ",(0,r.kt)("inlineCode",{parentName:"li"},"in")," or a ",(0,r.kt)("inlineCode",{parentName:"li"},"not in")," operator depending on whether the  ",(0,r.kt)("inlineCode",{parentName:"li"},"=")," or  ",(0,r.kt)("inlineCode",{parentName:"li"},"!=")," operator was used."),(0,r.kt)("li",{parentName:"ul"},"The list of internal values need to be comma delimited."),(0,r.kt)("li",{parentName:"ul"},"There can be one or many internal values and null is not allowed in this value set.")),(0,r.kt)("h2",null,"MaxTableDomain Based Filters"),(0,r.kt)("p",null,"You can also filter using the ",(0,r.kt)("inlineCode",{parentName:"p"},"maxtabledomain")," list WHERE clause. The ",(0,r.kt)("inlineCode",{parentName:"p"},"maxtabledomain")," is more useful for backward compatibility reasons with the older rest API and also in case a client wants to use an existing list WHERE clause that was created by using the table-domain. The API syntax is shown:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"GET <collection uri>?_fd=<maxtabledomain name>&_fdsite=<siteid>&_fdorg=<orgid>\n")),(0,r.kt)("p",null,"This API picks up the domain’s ",(0,r.kt)("inlineCode",{parentName:"p"},"listwhere")," and applies that to the collection. The site and organization are optional and needed if the ",(0,r.kt)("inlineCode",{parentName:"p"},"maxtabledomain")," is site/org scoped."),(0,r.kt)("h2",null,"Timeline Filters"),(0,r.kt)("p",null,"The timeline filters allow a simpler way to filter collections with time range based queries. The following example shows how you can list all work orders reported in the past three months:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"GET /oslc/os/mxapiwodetail?tlrange=-3M&tlattribute=reportdate\n")),(0,r.kt)("p",null,"This query finds all the work orders with a reportdate between today and the previous three months. The query is by default indexed around the current date. Another variation of this query is to range on a future date by switching the sign on the ",(0,r.kt)("inlineCode",{parentName:"p"},"tlrange")," to say ",(0,r.kt)("inlineCode",{parentName:"p"},"+3M")," instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"-3M"),". For ",(0,r.kt)("inlineCode",{parentName:"p"},"reportdate")," a future date range may not be good use case, but it would for date attributes like scheduled date that can be in the future. You might also use the current date as an index and filter around that date using the +- notation as shown in the following example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"&tlrange=+-3Y\n")),(0,r.kt)("p",null,"This query filters records from three years in the past and three years in the future that is indexed on the current date. If you do not want to index on the current date, you can specify the date that you want to use for the index. The following example shows how you can specify the date:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"&tlattribute=reportdate=<some iso date>\n")),(0,r.kt)("h2",null,"Classification Attribute Search"),(0,r.kt)("p",null,"Maximo objects, such as assets, locations, items, and work orders can be associated with classifications to provides a way to associate classification metadata (aka ",(0,r.kt)("inlineCode",{parentName:"p"},"classification attributes"),") to the objects. These objects (assets,locations etc) are searched for based on those attribute values. This search capability is known as the attribute search feature. The following example shows an attributesearch that is applied to the asset MBO by using the MXAPIASSET object structure."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"GET oslc/os/mxapiasset?attributesearch=[SPEED:>=50]\n")),(0,r.kt)("p",null,"All assets that have a class spec attribute called ",(0,r.kt)("inlineCode",{parentName:"p"},"SPEED")," with a value ",(0,r.kt)("inlineCode",{parentName:"p"},">=50")," are searched for. If the value ",(0,r.kt)("inlineCode",{parentName:"p"},":>=50")," is not defined, then assets that have ",(0,r.kt)("inlineCode",{parentName:"p"},"SPEED")," as a specific attribute is returned."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"GET oslc/os/mxapiasset?attributesearch=[SPEED]\n")),(0,r.kt)("p",null,"It would have only fetched assets that have SPEED as a spec attribute. To combine multiple attributes in the search, you can use the following example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"GET oslc/os/mxapiasset?attributesearch=[SPEED:>=50;AREA;ELEV:=300]\n")),(0,r.kt)("p",null,"This query searches for assets that have a class spec attribute ",(0,r.kt)("inlineCode",{parentName:"p"},"SPEED")," with a value that is greater than 50, an attribute named AREA, and attribute name ELEV with a value of 300, all ANDed together."),(0,r.kt)("p",null,"This feature is in addition to the ",(0,r.kt)("inlineCode",{parentName:"p"},"oslc.where/savedquery")," query parameter. So you can use this feature along with the other filtering capabilities that are supported in this API framework."))}d.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-query-filtering-mdx-4d4f5d357cb7d21d6c4f.js.map