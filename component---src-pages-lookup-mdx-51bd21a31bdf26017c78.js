"use strict";(self.webpackChunkmas_playbook=self.webpackChunkmas_playbook||[]).push([[7738],{3624:function(e,t,a){a.d(t,{Z:function(){return y}});var o=a(7294),l=a(8650),n=a.n(l),i=a(1597),s=a(811),r=a(87),c=a(5900),m=a.n(c),d=function(e){var t,a=e.title,l=e.theme,n=e.tabs,i=void 0===n?[]:n;return o.createElement("div",{className:m()("PageHeader-module--page-header--NqfPe",(t={},t["PageHeader-module--with-tabs--vbQ-W"]=i.length,t["PageHeader-module--dark-mode--WCeH8"]="dark"===l,t))},o.createElement("div",{className:"bx--grid"},o.createElement("div",{className:"bx--row"},o.createElement("div",{className:"bx--col-lg-12"},o.createElement("h1",{id:"page-title",className:"PageHeader-module--text--Er2EO"},a)))))},p=function(e){var t=e.relativePagePath,a=e.repository,l=(0,i.useStaticQuery)("1364590287").site.siteMetadata.repository,n=a||l,s=n.baseUrl,r=n.subDirectory,c=s+"/edit/"+n.branch+r+"/src/pages"+t;return s?o.createElement("div",{className:"bx--row EditLink-module--row--BEmSX"},o.createElement("div",{className:"bx--col"},o.createElement("a",{className:"EditLink-module--link--IDrl1",href:c},"Edit this page on GitHub"))):null},u=a(4703),h=a(1721),b=function(e){function t(){return e.apply(this,arguments)||this}return(0,h.Z)(t,e),t.prototype.render=function(){var e=this.props,t=e.title,a=e.tabs,l=e.slug,s=l.split("/").filter(Boolean).slice(-1)[0],r=a.map((function(e){var t,a=n()(e,{lower:!0,strict:!0}),r=a===s,c=new RegExp(s+"/?(#.*)?$"),d=l.replace(c,a);return o.createElement("li",{key:e,className:m()((t={},t["PageTabs-module--selected-item--aBB0K"]=r,t),"PageTabs-module--list-item--024o6")},o.createElement(i.Link,{className:"PageTabs-module--link--Kz-7R",to:""+d},e))}));return o.createElement("div",{className:"PageTabs-module--tabs-container--Cdfzw"},o.createElement("div",{className:"bx--grid"},o.createElement("div",{className:"bx--row"},o.createElement("div",{className:"bx--col-lg-12 bx--col-no-gutter"},o.createElement("nav",{"aria-label":t},o.createElement("ul",{className:"PageTabs-module--list--xLqxG"},r))))))},t}(o.Component),g=b,k=a(7296),f=a(5387),w=a(3732),v=function(e){var t=e.date,a=new Date(t);return t?o.createElement(w.X2,{className:"last-modified-date-module--row--XJoYQ"},o.createElement(w.sg,null,o.createElement("div",{className:"last-modified-date-module--text--ogPQF"},"Page last updated: ",a.toLocaleDateString("en-GB",{day:"2-digit",year:"numeric",month:"long"})))):null},y=function(e){var t=e.pageContext,a=e.children,l=e.location,c=e.Title,m=t.frontmatter,h=void 0===m?{}:m,b=t.relativePagePath,w=t.titleType,y=h.tabs,E=h.title,N=h.theme,x=h.description,T=h.keywords,P=h.date,C=(0,f.Z)().interiorTheme,z=(0,i.useStaticQuery)("2456312558").site.pathPrefix,S=z?l.pathname.replace(z,""):l.pathname,G=y?S.split("/").filter(Boolean).slice(-1)[0]||n()(y[0],{lower:!0}):"",Z=N||C;return o.createElement(r.Z,{tabs:y,homepage:!1,theme:Z,pageTitle:E,pageDescription:x,pageKeywords:T,titleType:w},o.createElement(d,{title:c?o.createElement(c,null):E,label:"label",tabs:y,theme:Z}),y&&o.createElement(g,{title:E,slug:S,tabs:y,currentTab:G}),o.createElement(k.Z,{padded:!0},a,o.createElement(p,{relativePagePath:b}),o.createElement(v,{date:P})),o.createElement(u.Z,{pageContext:t,location:l,slug:S,tabs:y,currentTab:G}),o.createElement(s.Z,null))}},8741:function(e,t,a){a.r(t),a.d(t,{_frontmatter:function(){return s},default:function(){return m}});var o=a(3366),l=(a(7294),a(4983)),n=a(3624),i=["components"],s={},r={_frontmatter:s},c=n.Z;function m(e){var t=e.components,a=(0,o.Z)(e,i);return(0,l.kt)(c,Object.assign({},r,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"Often while designing applications we would need to provide the lookups for a given attribute. Attributes in Maximo objects can have variousl types of domains or field validation classes associated with them. Those can be leveraged by the application developer (of the Mbo) to provide conditional set of lookup records. Fortunately, there is a way to leverage that logic using the REST apis. A sample below shows how to get a list of possible status for a workorder status attribute."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"GET /oslc/os/mxapiwodetail/{id}/getlist~status?oslc.select=*&oslc.pageSize=10....\n")),(0,l.kt)("p",null,"Note that the above example uses a specific workorder Mbo {id} and does a ",(0,l.kt)("inlineCode",{parentName:"p"},"getlist")," on this Mbo on the attribute ",(0,l.kt)("inlineCode",{parentName:"p"},"status"),". The generic template is "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"GET /oslc/os/<os name>/{id}/getlist~<attribute name>?oslc.select=*&oslc.pageSize=10....\n")),(0,l.kt)("p",null,"These calls can be done on child objects too. The example belows demonstrates that."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"GET /oslc/os/<os name>/{id}/<child relation>/{id}/getlist~<attribute name>?oslc.select=*&oslc.pageSize=10....\n")),(0,l.kt)("p",null,"As you understand from this template, it is a collection query which follows all the syntaxes descibed in the previous sections. his implies you can put an order by, oslc.select, paging, oslc.where and time line queries and every thing else supported in a collection query. Note also that this same template can be used for list tab filter lookups. Note that in the list tab, you will need to do the lookup on an attribute based on no real mbos as the list tab is a collection of mboâ€™s. The rest api below uses the Maxiumo zombie mbo concept to do the lookup."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"GET /oslc/os/<os name>/zombie/getlist~<attribute name>?oslc.select=*&oslc.pageSize=10....\n")),(0,l.kt)("p",null,"Similarly, if you were to provide a lookup on a new instance of say workorder, you can use the rest query below"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"GET /oslc/os/<os name>/newmbo/getlist~<attribute name>?oslc.select=*&oslc.pageSize=10....\n")),(0,l.kt)("p",null,"Note that in both the above example ",(0,l.kt)("inlineCode",{parentName:"p"},"zombie")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"newmbo")," are key words recognized by the REST api framework. Note that these calls will return the json response by evaluating the field validation getList or the domain getList logic and hence the object type (ie assets/locations/items/alndomain/synonymdomain/numericdomain etc) returned would be totally controlled by the server side application lookup logic."),(0,l.kt)("p",null,"It is also possible that in certain cases, the lookup logic needs some more context than what is available in a zombie/new mbo or for that matter a mbo loaded from the db ({id}). This happens when say the end user sets value to a few related attributes that modify the selection filter for the lookup. To handle this extra transient context we can use a query parameter ",(0,l.kt)("inlineCode",{parentName:"p"},"setupdata"),". An template example is shown below"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'GET /oslc/os/<os name>/newmbo/getlist~att3?oslc.select=*&oslc.pageSize=10&setupdata={"attr1":"value1","attr2":10}\n')),(0,l.kt)("p",null,"As evident from the above example, you can pass in a json content to set value to attr1 and attr2 for the  ",(0,l.kt)("inlineCode",{parentName:"p"},"newmbo")," mbo. This will poetantially impact the lookup for the attribute attr3. Now this needs some knowledge from the client side to pass in the required attribute values. That knowledge may come from looking at the relation where clause or from knowing the internal working of the application mbo. "))}m.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-lookup-mdx-51bd21a31bdf26017c78.js.map