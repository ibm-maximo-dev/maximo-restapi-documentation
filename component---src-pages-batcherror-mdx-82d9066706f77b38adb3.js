"use strict";(self.webpackChunkmas_playbook=self.webpackChunkmas_playbook||[]).push([[9310],{3624:function(e,t,a){a.d(t,{Z:function(){return y}});var r=a(7294),n=a(8650),o=a.n(n),l=a(1597),s=a(811),i=a(87),c=a(5900),u=a.n(c),m=function(e){var t,a=e.title,n=e.theme,o=e.tabs,l=void 0===o?[]:o;return r.createElement("div",{className:u()("PageHeader-module--page-header--NqfPe",(t={},t["PageHeader-module--with-tabs--vbQ-W"]=l.length,t["PageHeader-module--dark-mode--WCeH8"]="dark"===n,t))},r.createElement("div",{className:"bx--grid"},r.createElement("div",{className:"bx--row"},r.createElement("div",{className:"bx--col-lg-12"},r.createElement("h1",{id:"page-title",className:"PageHeader-module--text--Er2EO"},a)))))},d=function(e){var t=e.relativePagePath,a=e.repository,n=(0,l.useStaticQuery)("1364590287").site.siteMetadata.repository,o=a||n,s=o.baseUrl,i=o.subDirectory,c=s+"/edit/"+o.branch+i+"/src/pages"+t;return s?r.createElement("div",{className:"bx--row EditLink-module--row--BEmSX"},r.createElement("div",{className:"bx--col"},r.createElement("a",{className:"EditLink-module--link--IDrl1",href:c},"Edit this page on GitHub"))):null},h=a(4703),p=a(1721),b=function(e){function t(){return e.apply(this,arguments)||this}return(0,p.Z)(t,e),t.prototype.render=function(){var e=this.props,t=e.title,a=e.tabs,n=e.slug,s=n.split("/").filter(Boolean).slice(-1)[0],i=a.map((function(e){var t,a=o()(e,{lower:!0,strict:!0}),i=a===s,c=new RegExp(s+"/?(#.*)?$"),m=n.replace(c,a);return r.createElement("li",{key:e,className:u()((t={},t["PageTabs-module--selected-item--aBB0K"]=i,t),"PageTabs-module--list-item--024o6")},r.createElement(l.Link,{className:"PageTabs-module--link--Kz-7R",to:""+m},e))}));return r.createElement("div",{className:"PageTabs-module--tabs-container--Cdfzw"},r.createElement("div",{className:"bx--grid"},r.createElement("div",{className:"bx--row"},r.createElement("div",{className:"bx--col-lg-12 bx--col-no-gutter"},r.createElement("nav",{"aria-label":t},r.createElement("ul",{className:"PageTabs-module--list--xLqxG"},i))))))},t}(r.Component),g=b,E=a(7296),f=a(5387),w=a(3732),v=function(e){var t=e.date,a=new Date(t);return t?r.createElement(w.X2,{className:"last-modified-date-module--row--XJoYQ"},r.createElement(w.sg,null,r.createElement("div",{className:"last-modified-date-module--text--ogPQF"},"Page last updated: ",a.toLocaleDateString("en-GB",{day:"2-digit",year:"numeric",month:"long"})))):null},y=function(e){var t=e.pageContext,a=e.children,n=e.location,c=e.Title,u=t.frontmatter,p=void 0===u?{}:u,b=t.relativePagePath,w=t.titleType,y=p.tabs,k=p.title,N=p.theme,T=p.description,x=p.keywords,P=p.date,B=(0,f.Z)().interiorTheme,C=(0,l.useStaticQuery)("2456312558").site.pathPrefix,A=C?n.pathname.replace(C,""):n.pathname,S=y?A.split("/").filter(Boolean).slice(-1)[0]||o()(y[0],{lower:!0}):"",D=N||B;return r.createElement(i.Z,{tabs:y,homepage:!1,theme:D,pageTitle:k,pageDescription:T,pageKeywords:x,titleType:w},r.createElement(m,{title:c?r.createElement(c,null):k,label:"label",tabs:y,theme:D}),y&&r.createElement(g,{title:k,slug:A,tabs:y,currentTab:S}),r.createElement(E.Z,{padded:!0},a,r.createElement(d,{relativePagePath:b}),r.createElement(v,{date:P})),r.createElement(h.Z,{pageContext:t,location:n,slug:A,tabs:y,currentTab:S}),r.createElement(s.Z,null))}},5338:function(e,t,a){a.r(t),a.d(t,{_frontmatter:function(){return s},default:function(){return u}});var r=a(3366),n=(a(7294),a(4983)),o=a(3624),l=["components"],s={},i={_frontmatter:s},c=o.Z;function u(e){var t=e.components,a=(0,r.Z)(e,l);return(0,n.kt)(c,Object.assign({},i,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("p",null,"Certain use cases require the REST POST calls to create/update Mbo’s (using Objec Structures) to batch up the errors and not return on first error. This potentially will be good use case in UI’s that leverage the REST apis to show all errors at once to the end user as opposed to showing them one at a time.\nTo acheive this just set the request header `batcherror:1’. This will batch all errors together. A sample is shown below"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"POST /oslc/os/mxapiasset?lean=1\nbatcherror: 1\n")),(0,n.kt)("p",null,"Body:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-json"},'{\n   "assetnum":"A100",\n   "siteid":"BEDFORD",\n   "assettype":"BLAH",\n   "location":"BAH"\n}  \n')),(0,n.kt)("p",null,"In here, you will find that the asset type and the location are both invalid values. If you submit it without the batcherror:1 header, you will get the usual error json with one error - which probably in this case would be the location error. But for this request, with the said header, the error response would be batched. Sample below shows the batched striucture of the error."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-json"},'{\n   "attrerrors":[\n   {\n      "Error":{\n      "errorattrname": "location",\n      "errorobjpath": "asset",\n      "reasonCode": "BMXAA2661E",\n      "message": "BMXAA2661E - Location YES is not a valid location.",\n      "statusCode": "400"\n      ....\n      }\n   },\n   {\n     "Error":{\n     "errorattrname": "assettype",\n     "errorobjpath": "asset",\n     "reasonCode": "BMXAA4190E",\n     "message": "BMXAA4190E - Type BLAH is not in the value list.",\n     "statusCode": "400"\n     ....\n    }\n  }\n  ],\n  "Error":{the existing structure of single error}\n }\n')),(0,n.kt)("p",null,"Now you will figure out that this ",(0,n.kt)("inlineCode",{parentName:"p"},"attrerrors")," is the added piece that contains the batched array of attribute errors. To be backward compatible, this error also retains the single error block - which can be ignored if you are processing the ",(0,n.kt)("inlineCode",{parentName:"p"},"attrerrors")," section.\nNote that there are certain scenarios where this will not work as batch - for example when the error say involves an invalid site or org attrbute value that are part of the primary key. "))}u.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-batcherror-mdx-82d9066706f77b38adb3.js.map