"use strict";(self.webpackChunkmas_playbook=self.webpackChunkmas_playbook||[]).push([[6521],{3624:function(e,t,a){a.d(t,{Z:function(){return E}});var n=a(7294),l=a(8650),o=a.n(l),i=a(1597),r=a(811),s=a(87),m=a(5900),c=a.n(m),h=function(e){var t,a=e.title,l=e.theme,o=e.tabs,i=void 0===o?[]:o;return n.createElement("div",{className:c()("PageHeader-module--page-header--NqfPe",(t={},t["PageHeader-module--with-tabs--vbQ-W"]=i.length,t["PageHeader-module--dark-mode--WCeH8"]="dark"===l,t))},n.createElement("div",{className:"bx--grid"},n.createElement("div",{className:"bx--row"},n.createElement("div",{className:"bx--col-lg-12"},n.createElement("h1",{id:"page-title",className:"PageHeader-module--text--Er2EO"},a)))))},u=function(e){var t=e.relativePagePath,a=e.repository,l=(0,i.useStaticQuery)("1364590287").site.siteMetadata.repository,o=a||l,r=o.baseUrl,s=o.subDirectory,m=r+"/edit/"+o.branch+s+"/src/pages"+t;return r?n.createElement("div",{className:"bx--row EditLink-module--row--BEmSX"},n.createElement("div",{className:"bx--col"},n.createElement("a",{className:"EditLink-module--link--IDrl1",href:m},"Edit this page on GitHub"))):null},d=a(4703),p=a(1721),b=function(e){function t(){return e.apply(this,arguments)||this}return(0,p.Z)(t,e),t.prototype.render=function(){var e=this.props,t=e.title,a=e.tabs,l=e.slug,r=l.split("/").filter(Boolean).slice(-1)[0],s=a.map((function(e){var t,a=o()(e,{lower:!0,strict:!0}),s=a===r,m=new RegExp(r+"/?(#.*)?$"),h=l.replace(m,a);return n.createElement("li",{key:e,className:c()((t={},t["PageTabs-module--selected-item--aBB0K"]=s,t),"PageTabs-module--list-item--024o6")},n.createElement(i.Link,{className:"PageTabs-module--link--Kz-7R",to:""+h},e))}));return n.createElement("div",{className:"PageTabs-module--tabs-container--Cdfzw"},n.createElement("div",{className:"bx--grid"},n.createElement("div",{className:"bx--row"},n.createElement("div",{className:"bx--col-lg-12 bx--col-no-gutter"},n.createElement("nav",{"aria-label":t},n.createElement("ul",{className:"PageTabs-module--list--xLqxG"},s))))))},t}(n.Component),f=b,w=a(7296),g=a(5387),k=a(3732),y=function(e){var t=e.date,a=new Date(t);return t?n.createElement(k.X2,{className:"last-modified-date-module--row--XJoYQ"},n.createElement(k.sg,null,n.createElement("div",{className:"last-modified-date-module--text--ogPQF"},"Page last updated: ",a.toLocaleDateString("en-GB",{day:"2-digit",year:"numeric",month:"long"})))):null},E=function(e){var t=e.pageContext,a=e.children,l=e.location,m=e.Title,c=t.frontmatter,p=void 0===c?{}:c,b=t.relativePagePath,k=t.titleType,E=p.tabs,T=p.title,v=p.theme,N=p.description,x=p.keywords,P=p.date,_=(0,g.Z)().interiorTheme,C=(0,i.useStaticQuery)("2456312558").site.pathPrefix,S=C?l.pathname.replace(C,""):l.pathname,j=E?S.split("/").filter(Boolean).slice(-1)[0]||o()(E[0],{lower:!0}):"",q=v||_;return n.createElement(s.Z,{tabs:E,homepage:!1,theme:q,pageTitle:T,pageDescription:N,pageKeywords:x,titleType:k},n.createElement(h,{title:m?n.createElement(m,null):T,label:"label",tabs:E,theme:q}),E&&n.createElement(f,{title:T,slug:S,tabs:E,currentTab:j}),n.createElement(w.Z,{padded:!0},a,n.createElement(u,{relativePagePath:b}),n.createElement(y,{date:P})),n.createElement(d.Z,{pageContext:t,location:l,slug:S,tabs:E,currentTab:j}),n.createElement(r.Z,null))}},7248:function(e,t,a){a.r(t),a.d(t,{_frontmatter:function(){return r},default:function(){return c}});var n=a(3366),l=(a(7294),a(4983)),o=a(3624),i=["components"],r={},s={_frontmatter:r},m=o.Z;function c(e){var t=e.components,a=(0,n.Z)(e,i);return(0,l.kt)(m,Object.assign({},s,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",null,"Filtering"),(0,l.kt)("p",null,"We have discussed how to leverage the rel notation to inline related MboSets as well as using the basic relation name with the curly brace notation to inline the Object Structure child objects along with the parent data. This section will cover how to limit, filter or sort those child data sets while being inlined within their parent data set. All the query parameters for this child object collection operations follow a naming pattern which is ",(0,l.kt)("inlineCode",{parentName:"p"},"<mbo name>.<relation name>.<operator>"),". The mbo name token refers to the parent mbo name for the child MboSet we want to operate on. The relation name is the relation name from the parent mbo to the child MboSet. The operator determines what kind of inline operation you are trying to do on the child collection."),(0,l.kt)("p",null,"Below we list the query parameter types available to do this:"),(0,l.kt)("h2",null,"Where Filter"),(0,l.kt)("p",null,"The format of this query parameter is ",(0,l.kt)("inlineCode",{parentName:"p"},"<mbo_name>.<relation_name>.where"),". This will help us set the where clause filter for the child object identified by the mbo_name parent Mbo and the relation_name relation name. The syntax for the where clause exactly follows the oslc.where format with the target MboSet in context. For example if we were to filter on the polines in the MXPO Object Structure we will use this feature as below"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'GET /oslc/os/mxapipo?oslc.select=ponum,status,poline{polinenum,itemnum,linec ost}&po.poline.where=itemnum="*" and linecost>100.0\n')),(0,l.kt)("p",null,"This will show only the poline’s that have an intemnum and line cost greater than 100. Note this does not in any way impact the selection of the PO records."),(0,l.kt)("p",null,"To support the or clause on the where clause (instead of the default and) there is a query parameter ",(0,l.kt)("inlineCode",{parentName:"p"},"<mbo name>.<relation name>.opmodeor")," which if set to 1, will treat the where clause specified above as a or clause. This will result in fetching all lines that have either a itemnum or a line cost greater than 100."),(0,l.kt)("h2",null,"Timeline Filters"),(0,l.kt)("p",null,"The format for these query parameters are ",(0,l.kt)("inlineCode",{parentName:"p"},"<mbo_name>.<relation_name>.tlrange")," for the time line range (eg -3M or +2Y) and ",(0,l.kt)("inlineCode",{parentName:"p"},"<mbo_name>.<relation_name>.tlattribute")," (the attribute name of the child object on which to base the time-line on) following in the lines of the Timeline queries as explained earlier."),(0,l.kt)("p",null,"Note that these query child object filters help sift and limit what child objects we want to see inlined with the root object of the Object Structure. But if we need to show those child objects in a list or tabular form and then page through them and filter them, then we should consider using the relation name in the URI to traverse to that set as explained in the “Traversing to related MboSets” section. That way you will operate on the child collection independently and be able to page the collection."),(0,l.kt)("h1",null,"Sorting"),(0,l.kt)("p",null,"The format of this query parameter is ",(0,l.kt)("inlineCode",{parentName:"p"},"<mbo_name>.<relation_name>.orderBy"),". This will help us sorting the child collection. This follows the oslc.orderBy format and is applied to the context of the child collection."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"GET /oslc/os/mxapipo?oslc.select=ponum,status,poline{polinenum,itemnum,linecost}&po.poline.orderBy=-linecost&lean=1\n")),(0,l.kt)("p",null,"This will do a descending sort on the linecost for the poline collection."),(0,l.kt)("h1",null,"Paging - Limit Filter"),(0,l.kt)("p",null,"The format of this query parameter is ",(0,l.kt)("inlineCode",{parentName:"p"},"<mbo_name>.<relation_name>.limit"),". This will help us set the limit to the number of rows we want to retrieve for the child collection."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"GET /oslc/os/mxpo?oslc.select=ponum,status,poline{polinenum,itemnum,linecost}&po.poline.limit=1&lean=1\n")),(0,l.kt)("p",null,"This will limit the number of polines loaded to only 1 for each PO in the response."))}c.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-query-child-mdx-7b1bb9fc04ee4aa7c6f1.js.map