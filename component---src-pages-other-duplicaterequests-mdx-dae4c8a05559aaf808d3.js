"use strict";(self.webpackChunkmas_playbook=self.webpackChunkmas_playbook||[]).push([[5804],{3624:function(e,t,a){a.d(t,{Z:function(){return k}});var n=a(7294),r=a(8650),i=a.n(r),l=a(1597),o=a(811),s=a(87),c=a(5900),d=a.n(c),m=function(e){var t,a=e.title,r=e.theme,i=e.tabs,l=void 0===i?[]:i;return n.createElement("div",{className:d()("PageHeader-module--page-header--NqfPe",(t={},t["PageHeader-module--with-tabs--vbQ-W"]=l.length,t["PageHeader-module--dark-mode--WCeH8"]="dark"===r,t))},n.createElement("div",{className:"bx--grid"},n.createElement("div",{className:"bx--row"},n.createElement("div",{className:"bx--col-lg-12"},n.createElement("h1",{id:"page-title",className:"PageHeader-module--text--Er2EO"},a)))))},u=function(e){var t=e.relativePagePath,a=e.repository,r=(0,l.useStaticQuery)("1364590287").site.siteMetadata.repository,i=a||r,o=i.baseUrl,s=i.subDirectory,c=o+"/edit/"+i.branch+s+"/src/pages"+t;return o?n.createElement("div",{className:"bx--row EditLink-module--row--BEmSX"},n.createElement("div",{className:"bx--col"},n.createElement("a",{className:"EditLink-module--link--IDrl1",href:c},"Edit this page on GitHub"))):null},h=a(4703),p=a(1721),f=function(e){function t(){return e.apply(this,arguments)||this}return(0,p.Z)(t,e),t.prototype.render=function(){var e=this.props,t=e.title,a=e.tabs,r=e.slug,o=r.split("/").filter(Boolean).slice(-1)[0],s=a.map((function(e){var t,a=i()(e,{lower:!0,strict:!0}),s=a===o,c=new RegExp(o+"/?(#.*)?$"),m=r.replace(c,a);return n.createElement("li",{key:e,className:d()((t={},t["PageTabs-module--selected-item--aBB0K"]=s,t),"PageTabs-module--list-item--024o6")},n.createElement(l.Link,{className:"PageTabs-module--link--Kz-7R",to:""+m},e))}));return n.createElement("div",{className:"PageTabs-module--tabs-container--Cdfzw"},n.createElement("div",{className:"bx--grid"},n.createElement("div",{className:"bx--row"},n.createElement("div",{className:"bx--col-lg-12 bx--col-no-gutter"},n.createElement("nav",{"aria-label":t},n.createElement("ul",{className:"PageTabs-module--list--xLqxG"},s))))))},t}(n.Component),g=f,b=a(7296),v=a(5387),E=a(3732),w=function(e){var t=e.date,a=new Date(t);return t?n.createElement(E.X2,{className:"last-modified-date-module--row--XJoYQ"},n.createElement(E.sg,null,n.createElement("div",{className:"last-modified-date-module--text--ogPQF"},"Page last updated: ",a.toLocaleDateString("en-GB",{day:"2-digit",year:"numeric",month:"long"})))):null},k=function(e){var t=e.pageContext,a=e.children,r=e.location,c=e.Title,d=t.frontmatter,p=void 0===d?{}:d,f=t.relativePagePath,E=t.titleType,k=p.tabs,y=p.title,T=p.theme,N=p.description,P=p.keywords,x=p.date,C=(0,v.Z)().interiorTheme,q=(0,l.useStaticQuery)("2456312558").site.pathPrefix,Z=q?r.pathname.replace(q,""):r.pathname,H=k?Z.split("/").filter(Boolean).slice(-1)[0]||i()(k[0],{lower:!0}):"",S=T||C;return n.createElement(s.Z,{tabs:k,homepage:!1,theme:S,pageTitle:y,pageDescription:N,pageKeywords:P,titleType:E},n.createElement(m,{title:c?n.createElement(c,null):y,label:"label",tabs:k,theme:S}),k&&n.createElement(g,{title:y,slug:Z,tabs:k,currentTab:H}),n.createElement(b.Z,{padded:!0},a,n.createElement(u,{relativePagePath:f}),n.createElement(w,{date:x})),n.createElement(h.Z,{pageContext:t,location:r,slug:Z,tabs:k,currentTab:H}),n.createElement(o.Z,null))}},789:function(e,t,a){a.r(t),a.d(t,{_frontmatter:function(){return o},default:function(){return d}});var n=a(3366),r=(a(7294),a(4983)),i=a(3624),l=["components"],o={},s={_frontmatter:o},c=i.Z;function d(e){var t=e.components,a=(0,n.Z)(e,l);return(0,r.kt)(c,Object.assign({},s,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Often we will land up into a situation where the REST call committed successfully on the server, but the communication channel broke and the client got a 500 error. The client will think that the server rolled back the transaction and will end up re-sending the request. This in some cases can result in erroneous or duplicate data. To avoid this the REST api framework provides a mechanism to catch this double-dipping issue. The request for create/update/delete can contain a request header called ",(0,r.kt)("inlineCode",{parentName:"p"},"transactionid")," which the api framework will validate for duplication. If it finds no matches, the transaction is good to go. If however a match is found, the request is rejected with a HTTP 409 Conflict error."),(0,r.kt)("p",null,"Note that the transactionid header value is client generated and hence is the responsibility of the client code to make sure it is unique enough that is does not clash with another valid request. If the server does not find a match, it stores it as part of the request transaction commit so that in can reject future transactions with the same transaction id. The default life of the transaction id is 5 minutes, controlled by the escalation ",(0,r.kt)("inlineCode",{parentName:"p"},"OSLCTXN"),". However this can be modified as per the installation need."),(0,r.kt)("p",null,"Note that this feature is primarily useful when we are operating the REST client in an asynchronous or disconnected mode (much like the Anywhere platform). This feature may not make much sense for in the connected/interactive mode."))}d.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-other-duplicaterequests-mdx-dae4c8a05559aaf808d3.js.map